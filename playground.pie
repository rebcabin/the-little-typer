#lang pie  ;; Racket supports this language as a
           ;; package (`raco pkg install pie`)


;; [Here is a good article on the basics of type theory.](https://medium.com/@haliq12/homotopy-type-theory-hott-for-mere-mortals-8d28301a1b19).
;; In there, we find out that dependent type theory is not
;; just for programming languages.


;; [The Wikipedia article](https://en.wikipedia.org/wiki/Type_theory) is worth your time, too.


;; [Benjamin Pierce's book TAPL](https://www.cis.upenn.edu/~bcpierce/tapl/) is famous and on my
;; reading list for the future.


;; [Software Foundations is an interactive course](https://softwarefoundations.cis.upenn.edu/)
;; in Coq. I played around with it but came here for
;; something smaller and easier.


;;   ___ _                _   __       ___
;;  / __| |_  _ __ ___   / | / _|___  |_  )
;; | (__| ' \| '_ (_-<_  | | > _|_ _|  / /
;;  \___|_||_| .__/__(_) |_| \_____|  /___|
;;           |_|


;; In Emacs racket-mode, C-c C-c sends the whole
;; file to the racket interpreter. C-M-x sends the
;; s-exp that surrounds the cursor, just as with
;; CIDER in Clojure-mode.


;; I tried to do this whole thing in a Jupyter
;; notebook, but found that the racket kernel for
;; Jupyter was not up to the job on my Mac Book Pro
;; M1.


;; Alternatively, if you don't want to set up Emacs
;; for racket, load this file into DrRacket and play
;; around. DrRacket comes for free with [the racket
;; distribution](https://download.racket-lang.org/).
;; Install the distribution, type `raco pkg install
;; pie` at the terminal, launch `DrRacket` and party
;; on. DrRacket is a fine IDE if you can stand
;; imperfect Emacs key-binding emulation (I can't;
;; too many decades of muscle memory!)


;; Mostly, I leave two blank lines between things. I
;; leave one blank line between a `claim` and its
;; matching `define`. Writing these pairs _feels
;; like_ writing Haskell. I also sometimes leave a
;; single blank line between a definition and its
;; unit tests. I'm not religious about any of the
;; line-spacing.


'spinach


(the (Pair Atom Atom)                       ; type
     (cons 'spinach 'cauliflower))             ; instance


(the Atom (the Atom 'pie))                  ; instance only


;; -+-+-+-+-+-+-+-+-+-
;;  w h i c h - N a t
;; -+-+-+-+-+-+-+-+-+-


;; Here is my clone of which-Nat and its type
;; signature.


(claim wN
       (Π ((E      U        )
           (target Nat      )
           (base   E        )
           (step   (→ Nat E)))
          E))

(define wN
  (λ (E)
   (λ (t b s) (which-Nat t b s))))


;; The base and the output of step must have the same
;; type (E U). E can be anything -- Atom or Nat, for
;; instance, but it must be the same on both branches
;; of which-Nat.


;; Here is pseudocode for which-Nat:


;; (which-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then which-Nat = (step n-1)


;; A good name for the argument (parameter?) of step
;; is `n-1` because step is called with `n-1` when
;; `target` == `n` == `(add1 n-1)`.


;; A parameter is a name for an argument. What is
;; the name of a parameter (your answer)?


;; SPOILER: Parameters inhabit a space of symbolic
;; calculation inside the compiler or its run-time,
;; Names of parameters only appear in the
;; implementations of the compiler or its run-time
;; representative functions, where they may stand
;; for arbitrary parameters. At the user's level.
;; parameters are names for arguments, where they
;; may stand for arbitrary argument values. Recall
;; that values are expressions with constructors up
;; top (in first positions in parenthesized
;; expressions).


(which-Nat zero 'naught (λ (n-1) 'more))
; (the Atom 'naught)                    ; response from REPL
(which-Nat 4    'naught (λ (n-1) 'three))
; (the atom 'three)                     ; response from REPL


;; I made up the following to show how rec-Nat can
;; mimic the behavior of which-Nat, i.e., by the
;; step's ignoring both its arguments:


;;      target    base       step
;;       ---- ----------- ----------
(rec-Nat zero 'rec-naught (λ (n-1 r) 'rec-more))
; (the Atom 'rec-naught)
(rec-Nat 4    'rec-naught (λ (n-1 r) 'rec-three))
; (the Atom 'rec-three


;; Notice that both `which-Nat` and `rec-Nat` ignore
;; `step` when `target` is `zero`.


;; Notice that `rec-Nat` "destructures" its argument
;; into `(add1 n-1)` and then "eliminates" `add1`
;; before handing `n-1` to the `step` function,
;; `(λ (n-1 r) 'some-atom)`. More about
;; destructuring and elimination below.


;; The book writes ignored arguments in a dimmed,
;; grey, `dim` font. I think one need not bother
;; much about that here. But one might sometimes
;; write `_` or `foo_` with a `_` suffix for ignored
;; arguments. Lots of programming languages follow
;; that convention, sometimes allowing multiple
;; instances of `_` in an argument list without
;; collision.


;; Later, one will see that by `step`'s ignoring
;; argument `r`, the recursive computation,
;; `rec-Nat`, simulates `iter-Nat`.


;;   ___ _              _             ____
;;  / __| |_  __ _ _ __| |_ ___ _ _  |__ /
;; | (__| ' \/ _` | '_ \  _/ -_) '_|  |_ \
;;  \___|_||_\__,_| .__/\__\___|_|   |___/
;;                |_|


;; Frame 3.23


;; All the functions above follow a pattern, with
;; parameters `target`, `base`, and `step`.


;;        target base      step
;;       |------|----|----------------|
(iter-Nat    5     3  (λ (k) (add1 k)))


;; Discovery about pie (the language of this file):
;; cannot use `add1` instead of `(λ (k) (add1 k))`.
;; Later, one finds the reason: `add1` is not a
;; function; it's of an un-named primitive kind,
;; perhaps a macro. Later, one can see that it acts
;; like a value constructor in expressions like
;; `(add1 n-1)`.


;; (iter-Nat 5 3 add1)                  ; input to REPL
;;                                      : response from REPL:
;; .../the-little-typer/playground.pie:17:14:
;; add1: expected valid Pie name
;   at: add1
;   in: add1


;; -+-+-+-+-+-+-+-+-
;;  i t e r - N a t
;; -+-+-+-+-+-+-+-+-


;; pseudocode for iter-Nat:


;; (iter-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then iter-Nat ==
;; (step
;;    (iter-Nat
;;      n-1 base step))


;; `iter-Nat` has type
;;
;; (Π ((E U))
;;   (→ N E (→ N E) E))
;;      ^ ^  \_ _/  ^
;;       \ \   v     \
;;        \ \   \     type of return value
;;         \ \   type of `step`
;;          \ type of `base`
;;           type of `target`
;;
;; same as the type of `which-Nat`. The difference
;; between the two is that `iter-Nat` calls
;; `iter-Nat` internally for the argument of `step`.
;; User-defined code must not recurse explicitly,
;; but this system-defined routine can recurse
;; internally because it does type-checking along
;; the way or at compile time.


;; We must define `+`. It's not built-in:


;; (+ 2 3)                              ; input to REPL
; Unknown variable +                    ; response from REPL


;; When some input to the REPL produces an error
;; message, we must comment-out that input in this
;; source file. The REPL halts on any error. We want
;; to write down the errors, but we don't want to
;; halt the REPL once we figure out the fix.


;; -----------------------------------------------
(claim step-+
       (→ Nat Nat))

(define step-+
  (λ (n-1) (add1 n-1)))


;; -----------------------------------------------
(claim + (→ Nat Nat Nat))

(define +
  (λ (n j) ;; Don't use the name `n-1` here.
    ;;        target base  step  ; the pattern
    ;;       |------|----|-------|
    (iter-Nat    n     j   step-+ )))


;; Frame 3.28, sort-of


;; reminder of the pseudocode of which-Nat:


;; (which-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then which-Nat = (step n-1)


;; -+-+-+-+-+-+-+-+-+-+-+-
;;  e l i m i n a t i o n
;; -+-+-+-+-+-+-+-+-+-+-+-


;; The process of replacing `(add1 n-1)` with `n-1`
;; is "elimination" because it strips off --
;; eliminates -- the value constructor `add1`.
;; Selection (`which-Nat`), iteration (`iter-Nat`),
;; and recursion (`rec-Nat`) work in a backwards
;; kind of way, by eliminating toward zero. One says
;; "backwards" because one's prior experience with
;; recursion and iteration probably has one starting
;; with some big Nat and _subtracting_ 1 from it
;; before recursing. Here, in The Little Typer, one
;; instead destructures larger numbers `n` into
;; smaller ones `(add1 n-1)` by writing out the
;; _addition_ that "must have taken place." The
;; effect is the same, but preserves type
;; information.


;; Sequential deconstruction and elimination _build
;; up_ expressions of smaller Nats. The eliminators
;; _rattle down_ those expressions in O(n) time to
;; produce final results in the unique normal form
;; -- the "most direct" form.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  d e s t r u c t u r i n g
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-


;; The invisible process of noticing that
;; `n == (add1 n-1)` is "destructuring," a term not
;; in The Little Typer. I borrowed it from Clojure.
;; One might think it should "structuring" because
;; it substitutes a value like `(add1 n-1)`, with a
;; constructor up top, for an expression like `n`.
;; However, I always pair destructuring with a
;; following elimination, so destructuring is more a
;; partner of elimination than it is a stand-alone
;; operation. Also, I wanted to mimic Clojure, which
;; unpacks variable-binding expressions into value
;; forms, typically with Clojure keywords up top
;; taking the role of Pie's constructors.
;; Destructuring might better be called _pattern
;; matching_, but The Little Typer has a specific
;; meaning for _pattern matching_ in an Appendix and
;; I don't want to collide names.


;; Destructuring, in our example, defines the
;; argument `n-1` by setting up the value
;; `(add1 n-1)` [constructor `add1` up top, as if a
;; Clojure keyword] for later elimination to `n-1`.


;; (iter-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;;                               |-------------|
;;                                destructuring
;; then iter-Nat ==        ______/
;;                        /
;;             elimination
;; (step       |---------|
;;    (iter-Nat    n-1    base step))


;; Iter-Nat is [an "eliminator" for Nats](https://docs.racket-lang.org/pie/#%28def._%28%28lib._pie%2Fmain..rkt%29._iter-.Nat%29%29).


;; Here is a "same-chart" -- a hand calculation --
;; for `(+ 2 3)`. I assume one understands "subst.",
;; i.e., substitution, without further explanation:


(+ 2 3) ; step 1. ...                     how? why?
;; 2.     (iter-Nat     2    3 step-+)    subst. def
;; 3.     (iter-Nat (add1 1) 3 step-+)    destructuring
;; 4. (step-+            /                elimination
;;        (iter-Nat     1    3 step-+))   ... always together
;; 5. (step-+       ____^___
;;        (iter-Nat (add1 0) 3 step-+))   destructuring
;; 6. (step-+            /                elimination
;;      (step-+         |                 ... line handmaidens
;;        (iter-Nat     0    3 step-+)))
;;        -------------------v--------
;; 7. (step-+                |            subst. base
;;      (step-+              3))
;; ~~~> 5                                 rattle-down evaluation


;; Here is something I made up to show that
;; `rec-Nat` is at least as strong as `iter-Nat`. In
;; the following example, the `step` function body
;; ignores its recursive argument `r`, so we write
;; it `r_` by the naming convention that ignored
;; variables have a `_` suffix.


;; reminder of `rec-Nat`:


;; (rec-Nat target base step) == base if
;; target == 0 else if target == (add1 n-1)
;; then rec-Nat ==
;; (step n-1                              nota bene
;;    (rec-Nat n-1 base step))            elimination


;; -----------------------------------------------
(claim sr+
       (→ Nat Nat Nat))

(define sr+
  (λ (n-1 r_) (add1 n-1))) ;              ignore r == r_


(rec-Nat 2 3 sr+) ; step 1. ...
;; 2.     (rec-Nat     2    3 sr+)        subst. def
;;                 ____^___
;; 3.     (rec-Nat (add1 1) 3 sr+)        destructuring
;; 4. (sr+ 1            /                 elimination
;;        (rec-Nat     1    3 sr+))       ... always together
;; 5. (sr+ 1       ____^___               destructuring
;;        (rec-Nat (add1 0) 3 sr+))
;; 6. (sr+ 0            /                 elimination
;;      (sr+ 0         |                  ... like handmaidens
;;        (rec-Nat     0    3 sr+)))
;;        ------------------v-----        subst. base
;; 7. (sr+ 0                |
;;      (sr+ 0              3))
;; ~~~> 5                                 rattle-down evaluation


;; -+-+-+-+-+-
;;  g a u s s
;; -+-+-+-+-+-


;; The steppers in the `rec-Nat` example above
;; ignores the recursive argument `r == r_`. Here is
;; an example of a `rec-Nat` stepper that uses both
;; arguments, including `r == rg`, i.e., `r` gauss:


;; -----------------------------------------------
(claim step-gauss
       (→ Nat Nat
          Nat))

(define step-gauss
  (λ (n-1 rg)
    (+ (add1 n-1) rg)))


(claim gauss
       ;;  n  output
       (→ Nat Nat))

(define gauss
  (λ (n) ; Don't name this argument n-1
    (rec-Nat n ; `target`: if zero, return ...
             0 ; `base`: else, if target is `(add1 n-1)`
             ;; return
             ;; (step-gauss
             ;;   (rec-Nat n-1
             ;;            base
             ;;            step-gauss)
             step-gauss)))


;; Less noisy pseudocode:


;; letting rN == rec-Nat, s == some-stepper, a1 == add1
;; claim s (→ Nat Nat Nat)
;; (rN     0    b s) ~~> b
;; (rN (a1 n-1) b s) ~~> (s n-1 (rN n-1 b s))


;; a step-chart calculated by hand:


(gauss 3) ; step 1. ...
;; 2.       (rN    3   0 sg)              subst. def
;;              ___^__
;; 3.       (rN (a1 2) 0 sg)              destructuring
;; 4. (sg 2        /                      elimination
;;          (rN    2   0 sg))             ... always together
;; 5. (sg 2     ___^__
;;          (rN (a1 1) 0 sg))             destructuring
;; 6. (sg 2        /                      elimination
;;      (sg 1      |                      ... like handmaidens
;;          (rN    1   0 sg)))
;; 6. (sg 2        |
;;      (sg 1   ___^__
;;          (rN (a1 0) 0 sg)))            destructuring
;; 7. (sg 2        /                      elimination
;;      (sg 1      |
;;        (sg 0    |
;;          (rN    0   0 sg))))
;; 8. (sg 2 -------v--------
;;      (sg 1      |
;;        (sg 0    0)))                   subst. base
;; 9. (sg 2 (sg 1 (+ (add1 0) 0)))        rattle-down evaluation
;; A. (sg 2 (sg 1 1))                     including
;; B. (sg 2 (+ (add1 1) 1))               multiple
;; C. (sg 2 3)                            steps not
;; D. (+ (add1 2) 3)                      exploded here
;; E. 6


;;   ___ _              _             _ _
;;  / __| |_  __ _ _ __| |_ ___ _ _  | | |
;; | (__| ' \/ _` | '_ \  _/ -_) '_| |_  _|
;;  \___|_||_\__,_| .__/\__\___|_|     |_|
;;                |_|


;; This chapter is mostly about the miniature
;; calculus on types, a calculus effected by Π. I
;; assume this is easy, so I don't talk much, just
;; show some examples. In Emacs, type M-C-x with the
;; cursor in an example to see its value in the
;; pie/racket interpreter.


;; (claim foo (→ A D))
;; Page 98:  ~" → is not up to the job "~


;; -+-+-+-+-
;;  f l i p
;; -+-+-+-+-


;; -----------------------------------------------
(claim flip
       (Π ((A U) (D U))
          (→ (Pair A D)
              (Pair D A))))

(define flip
  (λ (A D)
    (λ (p) ;; of type (Pair A D)
      (cons (cdr p) (car p)))))  ;; normal form!


;; We'll make much truck of the normal form later!


(flip Nat Nat)                          ; input to REPL
; (the (→ (Pair Nat Nat)                ; response from REPL
;         (Pair Nat Nat))
;      (λ (p)
;        (cons (cdr p)
;              (car p))))


((flip Nat Atom) (cons 17 'apple))
; (the (Pair Atom Nat)
;      (cons 'apple 17))

((flip Nat Nat) (cons 2 3))
; (the (Pair Nat Nat)
;      (cons 3 2))


;; -+-+-+-+-+-+-+-+-
;;  c u r r i e d !
;; -+-+-+-+-+-+-+-+-


(flip Nat Atom (cons 17 'apple))
; (the (Pair Atom Nat)
;      (cons 'apple 17))

(flip Nat Nat (cons 2 3))
; (the (Pair Nat Nat)
;      (cons 3 2))


;; The following makes THE VERY IMPORTANT POINT that
;; CONSTRUCTORS like `cons` and `add1` ARE NOT
;; FUNCTIONS! You CAN'T CURRY THEM!


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  c o n s   i s   n o t   a   F u n c t i o n !
;;       ( c a n ' t   c u r r y   i t )
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; (flip Nat Atom (cons 17 'apple))
; cons: expected valid Pie name
;   at: cons
;   in: cons


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  W r i t e   Y o u r   O w n   E l i m i n a t o r
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; -----------------------------------------------
(claim elim-Pair
       (Π ((A U) (D U) (X U))
          (→ (Pair A D)
             (→ A D X)
             X)))

(define elim-Pair
  (λ (A D X)
    (λ (p f)
      (f (car p) (cdr p)))))

elim-Pair
; (the (Π ((A U)
;          (D U)
;          (X U))
;         (→ (Pair A D)
;            (→ A D
;               X)
;            X))
;      (λ (A D X p f)
;        (f (car p)
;           (cdr p))))

(elim-Pair Nat Atom Nat)
; (the (→ (Pair Nat Atom)
;         (→ Nat Atom
;            Nat)
;         Nat)
;      (λ (p f)
;        (f (car p)
;           (cdr p))))


;; -+-+-+-+-+-+-+-+-
;;  k a r ,   k d r
;; -+-+-+-+-+-+-+-+-


;; These `kar` and `kdr` functions are specialized
;; for Nats. `kar` and `kdr` are probably lousy
;; names for them, but go with them just to exit the
;; chapter. `elim-pair` is not specialized, so
;; bracket the function-calls appropriately.


;; -----------------------------------------------
(claim kar
       (→ (Pair Nat Nat) Nat))

(define kar
  (λ (p)
    ((elim-Pair Nat Nat Nat) ; specialized on Nats
               p
               (λ (a d_) a)))) ; ignore argument d

kar
; (the (→ (Pair Nat Nat)
;         Nat)
;      (λ (p)
;        (car p)))

(kar (cons 2 3))
; (the Nat 2)


;; -----------------------------------------------
(claim kdr
       (→ (Pair Nat Nat) Nat))

(define kdr
  (λ (pn)
    ((elim-Pair Nat Nat Nat) ; specialized on Nats
               pn
               (λ (a_ d) d)))) ; ignore argument a

(kdr (cons 2 3))
; (the Nat 3)


;; Frame 4.50


;; -+-+-+-+-
;;  t w i n
;; -+-+-+-+-


;; -----------------------------------------------
(claim twin
       (Π ((Y U))
          (→ Y (Pair Y Y))))

(define twin
  (λ (Y)
    (λ (x)
      (cons x x))))

((twin Atom) 'pew)
; (the (Pair Atom Atom)
;      (cons 'pew 'pew))


;; curried:


(twin Atom 'poe)
; (the (Pair Atom Atom)
;      (cons 'poe 'poe))



;;   ___ _              _             ___
;;  / __| |_  __ _ _ __| |_ ___ _ _  | __|
;; | (__| ' \/ _` | '_ \  _/ -_) '_| |__ \
;;  \___|_||_\__,_| .__/\__\___|_|   |___/
;;                |_|


;; No need for a lot of prose, here. Read the code!


;; Frame 5.31


;; -----------------------------------------------
(claim toppings (List Atom))

(define toppings
  (:: 'potato (:: 'butter nil)))


;; -----------------------------------------------
(claim condiments (List Atom))

(define condiments
  (:: 'chives
      (:: 'mayonnaise nil)))


;; -+-+-+-+-+-+-
;;  l e n g t h
;; -+-+-+-+-+-+-


;; reminder of `rec-Nat`:


;; letting rN == rec-Nat, s == some-stepper, a1 == add1
;; claim s (→ Nat Nat Nat)
;; (rN     0    b s) ~~> b
;; (rN (a1 n-1) b s) ~~> (s n-1 (rN n-1 b s))


;; pseudocode for rec-List:
;; claim s (-> E (List E) X X)            stepper
;; claim b X                              base
;; claim t (List E)                       target


;; letting rL = rec-List, s == some-stepper, :: for
;; destructuring like `add1` (the "1" in add1 is
;; analogous to the additional E argument in the
;; stepper, s [Frame 5.27]; the book does not state
;; this, but it's obvious in retrospect!).
;; (rL    nil    b s) ~~> b
;; (rl (:: e es) b s) ~~> (s e es (rL es b s))


;; -----------------------------------------------
(claim step-length
       (Π ((E U))
          (→ E
             (List E)
             Nat
             Nat)))

(define step-length
  (λ (E)
    (λ (e es length-es)
      (add1 length-es))))


;; -----------------------------------------------
(claim length
       (Π ((E U))
          (→ (List E)
              Nat)))

(define length
  (λ (E)
    (λ (es)
      (rec-List es 0 (step-length E)))))


(length Nat nil)                        ; ~~> (the Nat 0)
(length Atom nil)                       ; ~~> (the Nat 0)


(length Nat (:: 42 nil))                ; ~~> (the Nat 1)
(length Atom (:: 'foo (:: 'bar nil)))   ; ~~> (the Nat 2)


(the (List Atom) nil)                   ; typed empty list
(the (List Nat)  nil)                   ; typed empty list


;; Frame 5.42


;; Specialized for the `Atom` type:


;; -----------------------------------------------
(claim length-Atom
       (→ (List Atom) Nat))

(define length-Atom
  (length Atom))


;; Frame 5.45


;; -+-+-+-+-+-+-
;;  a p p e n d
;; -+-+-+-+-+-+-


;; `step-append` is called post-destructuring into
;; `(:: e es)` and post-elimination of `::`, just as
;; with `rec-Nat`. Destructuring and elimination are
;; handmaidens, destructuring before elimination.


;; -----------------------------------------------
(claim step-append
       (Π ((E U))
          (→ E
             (List E)
             (List E)
             (List E))))

(define step-append
  (λ (E)
    (λ (e es append-es)
      (:: e append-es))))


;; -----------------------------------------------
(claim append
       (Π ((E U))
          (→ (List E)
             (List E)
             (List E))))

(define append
  (λ (E)
    (λ (start end)
      (rec-List start end (step-append E)))))


((append Nat) nil nil)                  ; ~~> (the (List Nat) nil)
(append Nat nil nil)                    ; Everything's curried.


;; -----------------------------------------------
(claim append-Nat
       (→ (List Nat)
          (List Nat)
          (List Nat)))

(define append-Nat
  (append Nat))


(append-Nat (:: 1 nil) nil)
; (the (List Nat) (:: 1 nil))
(append-Nat nil (:: 2 nil))
(append-Nat (:: 1 nil) (:: 2 nil))
; You fill those in!


;; -+-+-+-+-+-+-+-
;;  r e v e r s e
;; -+-+-+-+-+-+-+-


;; -----------------------------------------------
(claim snoc
       (Π ((E U))
          (→ (List E) ; start
             E        ; element e
             (List E))))

(define snoc
  (λ (E)
    (λ (start e)
      (append E start (:: e nil)))))


;; The compiler detects, by type analysis, that
;; consing nil onto nil is illegal: it does not
;; produce a List!


;; illegal! compile error!


;; (snoc Nat nil nil)
; nil requires a List type, but was used as a Nat
;   Source locations:
;   playground.pie:54:14

(snoc Nat nil 1)
(snoc Nat (:: 1 nil) 2)
; You fill those in!


;; -----------------------------------------------
(claim step-reverse
       (Π ((E U))
          (→ E
             (List E)
             (List E)
             (List E))))


;; `step-reverse` is called post-destructuring into
;; `(:: e es)` and post-elimination of `::`, just as
;; with `rec-Nat`. So it gets two arguments, `e` and
;; `es`, as well as the recursive "almost,"
;; reversed.


(define step-reverse
  (λ (E)
    (λ (e es reversed)
      (snoc E reversed e))))


;; -----------------------------------------------
(claim reverse
       (Π ((E U))
          (→ (List E)
             (List E))))


;; I first wrote the `nil` below without peeking at
;; the answer. But the book snuck one in on me: too
;; clever by half! `nil` must be explicitly typed,
;; here. Not sure why type inference in Pie fails in
;; this case. The book is not clear about it.


(define reverse
  (λ (E)
    (λ (es)
      (rec-List es
                (the (List E) nil)
                ;; See sneaky footnote on Page 125!
                (step-reverse E)))))

(reverse Nat nil)
(reverse Nat (:: 1 nil))
(reverse Nat (:: 2 (:: 1 nil)))
; You fill those in!


;;   ___ _              _              __
;;  / __| |_  __ _ _ __| |_ ___ _ _   / /
;; | (__| ' \/ _` | '_ \  _/ -_) '_| / _ \
;;  \___|_||_\__,_| .__/\__\___|_|   \___/
;;                |_|


;; two expressions that produce types ("subtypes" of U):


(Vec Atom zero)                         ; (the U (Vec Atom 0))
(Vec Atom (add1 zero))                  ; (the U (Vec Atom 1))


;; `Vec` is like `List` that carries its length
;; along with it. A `Vec` of length 3 is of a
;; different type than a `Vec` of length 2. We'll
;; have to occasionally pass Nats around to remind
;; certain functions of the Nat part of a `Vec`
;; type.


;; Here is an instance expression (The Little Typer
;; through chapter 6 does not use the word
;; "instance" in this way, but I use it to mean a
;; value):


(the (Vec Atom zero) vecnil)            ; ~~> itself


;; Frame 6.21


;; head and tail are built-in, but they need
;; type-hints:


(head (the (Vec Atom 1) (vec:: 'a vecnil)))
                                        ; ~~> (the Atom 'a)


;; (head (vec:: 'a vecnil))
;; because
; Can't determine a type
;   Source locations:
;   playground.pie:71:6


(tail (the (Vec Atom 1) (vec:: 'a vecnil)))
                                        ; ~~> (the (Vec Atom 0) vecnil


;; -----------------------------------------------
(claim first-of-one
       (Π ((E U))
          (→ (Vec E 1) E)))

(define first-of-one
  (λ (E)
    (λ (es)
      (head es))))

(first-of-one Atom (vec:: 'shiitake vecnil))


;; Lots of expressions need type hints:


;; See https://stackoverflow.com/questions/75516108/vec-in-the-little-typer/75516109#75516109

(the (Vec Atom 1) (vec:: 'shiitake vecnil))
(the (Vec Atom 1) (vec:: (the Atom 'shiitake) vecnil))
(the (Vec Atom 1) (vec:: (the Atom 'shiitake)
                         (the (Vec Atom zero) vecnil)))
(the (Vec Atom 1) (vec:: 'shiitake
                         (the (Vec Atom zero) vecnil)))


;; -+-+-+-+-+-
;;  f i r s t
;; -+-+-+-+-+-


;; Frames 6.34 through 6.37


;;   __       __       ___ __
;;  / /____  / /____ _/ (_) /___ __
;; / __/ _ \/ __/ _ `/ / / __/ // /
;; \__/\___/\__/\_,_/_/_/\__/\_, /
;;                          /___/


;; This version of `first` requires a Nat argument,
;; `ℓ-1`, that is one fewer than the length of the
;; `Vec`. The argument must be one fewer than the
;; length so that `first` may be a total function;
;; so that neither its input nor its output may ever
;; be `vecnil`, that is, the sole `(Vec E 0)`.
;; `First` guarantees totality by destructuring
;; `ℓ-1` into `(add1 ℓ-1)`, which may never be
;; `zero`, then eliminating `add1` to yield `ℓ-1`,
;; which _can_ be `zero`.


;; The requirement that all functions be total gives
;; the type system great power to reject values that
;; might diverge, i.e., be non-terminating or empty.


;; `First` must be total, so its base type must be
;; some `Vec` with at least one element. The _type_
;; `(Vec E (add1 ℓ-1))` tells the whole story! Wow!


;; Note from the shorthand on Page 138 (Fifth
;; Printing), one might just as well write


;; -----------------------------------------------
(claim first
       (Π ((E U)
           (ℓ-1 Nat)
           (es (Vec E (add1 ℓ-1))))
          E))

(define first
  (λ (E_ ℓ_ es)
    (head es)))


;; As what I originally wrote (without peeking).
;; It's equivalent, but aggressively renames the Nat
;; argument from `ℓ` to `ℓ-1`.


;; (claim first
;;        (Π ((E U)
;;            (ℓ-1 Nat))
;;           (→ (Vec E (add1 ℓ-1))
;;              E)))

;; (define first
;;   (λ (E ℓ-1)
;;     (λ (es)
;;       (head es))))


(first Atom 2 (vec:: 'a (vec:: 'b (vec:: 'c vecnil))))
                                        ; ~~> (the Atom 'a)
(first Atom 0 (vec:: 'a vecnil))        ; ~~> (the Atom 'a)


;; The book captures the lesson about totality in
;; the slogan "Use a More Specific Type ... to weed
;; out unwanted arguments" on Page 137 (Fifth
;; Printing).


;; The rest of Chapter 6 seems to me just to
;; enshrine standard facts about the form of lambda
;; calculus that uses GREEK CAPITAL LETTER PI, Π.


;;   ___ _              _             ____
;;  / __| |_  __ _ _ __| |_ ___ _ _  |__  |
;; | (__| ' \/ _` | '_ \  _/ -_) '_|   / /
;;  \___|_||_\__,_| .__/\__\___|_|    /_/
;;                |_|


;; (define peas
;;   (λ (how-many-peas)
;;     (rec-Nat how-many-peas           ; target
;;           ;  ------v------
;;           ;    ____^_____
;;           ; == (add1 ℓ-1)
;;              vecnil                  ; base: type?
;;              (λ (ℓ-1_ peas_ℓ-1)      ; step: uh-oh
;;                (vec:: 'pea peas_ℓ-1)))))  ; type?


;; `peas` does not have a consistent type. `rec-Nat`
;; requires the type of `base` to be the same as
;; that of `peas_ℓ-1`. But, the type of base is
;;
;;     (Vec Atom 0),
;;
;; and the type of `peas_ℓ-1` is
;;
;;     (Vec Atom ℓ-1)
;;
;; and `ℓ-1` could be anything `>= 0`.


;; Any ___motive___ for types that depend on Nat has
;; type `(→ Nat U)`.


;; "The motive explains _why_ the target is to be
;; eliminated."


;; I would say "how the target is destructured?"
;; because I like to distinguish destructuring and
;; elimination. Why? because it helps me to name my
;; variables. If I point out that `n` is
;; destructured into `(add1 n-1)`, then it's clear
;; that the result of elimination, `n-1`, can be
;; zero whilst `n` can't and they both remain Nats.


;; Here is a shorthand synopsis for `ind-Nat`, which
;; does forward-rewriting by adding 1 to the input
;; of `step`. Backwards rewriting is done by
;; elimination on `(add1 n-1)`; that elimination
;; amounts to subtraction.


;; The motive, when applied to `zero`, returns
;; _the type of_ the base.


;; Letting iN be ind-Nat and a1 be add1:
;; claim mot (→ Nat U)
;; claim b   (mot zero)                   base
;; claim s   (Π ((n-1 Nat))               step
;;              (→ (mot    n-1)            forward ...
;;                 (mot (a1 n-1))))       ... rewriting
;;
;; claim iN
;; (Π ((t   Nat)                    ; target
;;     (m   (→ Nat U))              ; motive
;;     (b   (m 0))                  ; base
;;     (s   (Π ((n-1 Nat))          ; step
;;             (→ (m n-1)
;;                (m (add1 n-1))))))
;;    (m t))
;;
;; (iN      0     m b s) ~~> b == (m 0)
;; (iN (add1 ℓ-1) m b s) ~~>
;;   (s ℓ-1 (iN ℓ-1 m b s)) == (m (add1 ℓ-1))


;; -----------------------------------------------
(claim mot-peas
       (→ Nat U))

(define mot-peas
  (λ (k) (Vec Atom k)))

;; The motive returns a type:

(mot-peas zero)
; (the U                                ; response from REPL
;   (Vec Atom 0))

(mot-peas 1)
; (the U
;   (Vec Atom 1)


;; -----------------------------------------------
(claim base-peas
       (Vec Atom 0))

(define base-peas                       ; because of the claim,
  vecnil)                               ;   Pie knows the type


;; -----------------------------------------------
(claim step-peas
       (Π ((ℓ-1 Nat))
          (→ (mot-peas ℓ-1)
             (mot-peas (add1 ℓ-1)))))

(define step-peas
  (λ (ℓ-1)
    (λ (peas_ℓ-1)
      (vec:: 'pea peas_ℓ-1))))


;; -----------------------------------------------
(claim peas
       (Π ((ℓ Nat))
          (Vec Atom ℓ)))

(define peas
  (λ (ℓ)
    (ind-Nat ℓ
             mot-peas
             base-peas
             step-peas)))


;; M-C-x on these after loading the file via C-c C-c.


(peas 0)
(peas 1)
(peas 3)
; You fill in the responses!


;; I made up the following exercise for myself.


;; Check type-fu by defining a function that's the
;; same as `ind-Nat` (by technical meaning of "the
;; same?" It's difficult to check, because ind-Nat
;; isn't a function and doesn't have a normal form)


;; The [official documentation for ind-Nat is here](https://docs.racket-lang.org/pie/#%28def._%28%28lib._pie%2Fmain..rkt%29._ind-.Nat%29%29)

;; (ind-Nat target motive base step) → (motive target)
;; target : Nat
;; motive : (-> Nat U)
;; base   : (motive zero)
;; step	 	:	(Π ((n Nat))
;;            (-> (motive n)
;;            (motive (add1 n))))


;; I got some help on this self-inflicted "homework"
;; problem. [See here](https://racket.discourse.group/t/the-type-of-ind-nat-in-the-pie-language/1733).


;; -----------------------------------------------
(claim iN
       (Π ((target   Nat)               ; target
           (motive   (→ Nat U))         ; motive
           (base     (motive 0))        ; base
           (step     (Π ((n-1 Nat))     ; step
                        (→ (motive n-1)
                           (motive (add1 n-1))))))
          (motive target)))

(define iN
  (λ (target motive base step)
    (ind-Nat
     target
     motive
     base
     step)))


;; unit tests


;; -----------------------------------------------
(claim peas-ex
       (Π ((ℓ Nat))
          (Vec Atom ℓ)))

(define peas-ex
  (λ (ℓ)
    (iN ℓ
        mot-peas
        base-peas
        step-peas)))

(peas-ex 0)
(peas-ex 1)
(peas-ex 2)
; You fill in the responses!


;; Frame 7.27


;; `rec-Nat` can act like `ind-Nat` when `ind-Nat`
;; doesn't use its motive, because the types of
;; `target`, `base`, `step`, and `result` don't
;; change.


;; -----------------------------------------------
(claim also-rec-Nat
       (Π ((E U))
          (→ Nat                        ; target
             E                          ; base
             (→ Nat E E)                ; step
             E)))                       ; result

(define also-rec-Nat
  (λ (E)
    (λ (t b s)
      (ind-Nat
       t                                ; target
       (λ (k) E)                        ; motive_
       b                                ; base
       s))))                            ; step


;; -+-+-+-+-
;;  l a s t
;; -+-+-+-+-


;; Frame 7.38, Page 152 (Fifth Printing)


;; Motives are functions that return types. "The
;; motive applied to [E and] zero should be the type
;; of the base." The type of the base of `last` is
;;
;;     (→ (Vec E (add1 zero))
;;        E)
;;
;; that is, the type of a function of a singleton
;; `Vec` that returns the sole element of that
;; `Vec`.


;; -----------------------------------------------
(claim mot-last
       ;; extra type argument at the front:
       (→ U Nat U))


;; Can we be more specific?


;; (claim mot-last
;;        ;; extra type argument at the front:
;;        (Π ((E U))
;;           (the U (→ (Vec E Nat) E))))

(define mot-last
  (λ (E k-1)
    ;; Return a function from a singleton vec to an
    ;; element:
    (→ (Vec E (add1 k-1))
       E)))


;; The motive applied to zero must return the type
;; of a function that extracts the sole element of a
;; singleton `Vec`:


(mot-last Atom 0)
; (the U
;   (→ (Vec Atom 1) Atom)


;; The motive applied to bigger Nats return the
;; types of functions that can rattle out the last
;; from bigger `Vec`s:


(mot-last Atom 1)
; (the U
;   (→ (Vec Atom 2) Atom)


;; This shows why the following attempt at a more
;; specific type for `mot-last` fails:


;; (claim mot-last
;;        ;; extra type argument at the front:
;;        (Π ((E U))
;;           (the U (→ (Vec E Nat) E))))
; Expected
;   (→ (Vec E k-1)
;     E)
; but given U


;; The motive must be able to return multiple
;; different types!


;; Why would we want a more specific types? Because
;; having two `U`s in the type of the motive makes
;; us kind-of seasick. But, I don't see a way around
;; it! The return value must be "any type" and the
;; first input must be "any type."


;; -----------------------------------------------
(claim base-last
       (Π ((E U))
          ;; The result is the type of a function
          ;; that coughs up the sole element of a
          ;; singleton Vec. It's (mot-last Atom 0).
          (→ (Vec E (add1 zero))
             E)))

(define base-last
  (λ (E)
    (λ (singleton-vec)
      (head singleton-vec))))


;; -----------------------------------------------
(claim step-last
       (Π ((E U)
           (ℓ-1 Nat))
          ;; The result is the type of a function
          ;; that converts a motive of E and ℓ-1 to
          ;; a motive of E and ℓ == (add1 ℓ-1) by
          ;; "forward rewriting" (my terminology).
          (→ (mot-last E       ℓ-1 )
             (mot-last E (add1 ℓ-1)))))

;; Recall that these motives, after application to E
;; and a Nat, yield types of functions from `Vec`s to
;; elements of type `E`:

(define step-last
  (λ (E ℓ-1)
    (λ (mot-of-E-and-ℓ-1) ;; convert this bad boy
      ;; ... into a new function of a `Vec`, `es`,
      ;; which applies the motive to the tail of the
      ;; Vec:
      (λ (es)
        (mot-of-E-and-ℓ-1 (tail es))))))


;; -----------------------------------------------
(claim last
       (Π ((E   U  )
           (ℓ-1 Nat))
          ;; The result is the type of a function
          ;; from a vector of at least one element
          ;; to an element:
          (→ (Vec E (add1 ℓ-1))
             E)))

;; We can cons-up `last` almost blindly:

(define last
  (λ (E ℓ-1)
    (ind-Nat ℓ-1
             (mot-last E)
             (base-last E)
             (step-last E))))


;; and unit-test it:


(last Atom 1 (vec:: 'a (vec:: 'b vecnil)))
                                        ; ~~> (the Atom 'b)
(last Atom 0 (vec:: 'b vecnil))         ; ~~> (the Atom 'b)


;; Due to totality, we can't even write, let alone
;; compile, an expression that gets the last element
;; of an empty `Vec`. We can try


;; (last Atom 0 vecnil)
;  vecnil requires that the length be zero, not
;   1


;; -+-+-+-+-+-+-+-+-+-
;;  d r o p - l a s t
;; -+-+-+-+-+-+-+-+-+-


;; Frame 7.64, pg. 160 (Fifth Printing)


;; Motives are functions that return types. "The
;; motive applied to [E and] zero should be the type
;; of the base." The type of the base of `drop-last`
;; is the type of a function that converts a
;; singleton vector into an empty vector:
;;
;;     (→ (Vec E (add1 zero))
;;        (Vec E     zero   ))


;; -----------------------------------------------
(claim mot-drop-last
       ;; extra type argument at the front:
       (→ U Nat U))

(define mot-drop-last
  (λ (E ℓ-1)
    (→ (Vec E (add1 ℓ-1 ))
       (Vec E       ℓ-1 ))))


;; unit tests:


(mot-drop-last Atom zero)
; (the U
;    (→ (Vec Atom 1)
;       (Vec Atom 0)))

(mot-drop-last Atom 1)
; (the U
;    (→ (Vec Atom 2)
;       (Vec Atom 1)))


;; Frame 7.61


;; The base is a function of a singleton `Vec` that
;; returns an empty `Vec`:


;; -----------------------------------------------
(claim base-drop-last
       (Π ((E U))
          (→ (Vec E (add1 zero))
             (Vec E       zero ))))

(define base-drop-last
  (λ (E)
    (λ (es_)
      ;; Might be overkill to spell out the type.
      ;; Might write just `vecnil`. Maybe Pie can
      ;; reckon the type of `vecnil` here.
      (the (Vec E zero) vecnil))))


;; Frames 7.66-67


;; The type of `step-drop-last` is the type of a
;; function that converts a motive of `E` and `ℓ-1`
;; to a motive of `E` and `ℓ == (add1 ℓ-1)`. Except
;; for names, the claimed type of `step-drop-last`
;; is the same as the claimed type for `step-last`,
;; but the implementation differs.


;; -----------------------------------------------
(claim step-drop-last
       (Π ((E   U  )
           (ℓ-1 Nat))
          (→ (mot-drop-last E       ℓ-1 )
             (mot-drop-last E (add1 ℓ-1)))))

(define step-drop-last
  (λ (E ℓ-1)
    ;; From a function a longer `Vec`, return a
    ;; function from a shorter `Vec`:
    (λ (mot-of-E-and-ℓ-1)
      (λ (es)
        (vec:: (head es)
               (mot-of-E-and-ℓ-1 (tail es)))))))


;; We can blindly write the final function:


;; -----------------------------------------------
(claim drop-last
       (Π ((E   U  )
           (ℓ-1 Nat))
          ;; The result is the type of a function
          ;; from a vector of at least one element
          ;; to a vector of one fewer elements:
          (→ (Vec E (add1 ℓ-1))
             (Vec E     ℓ-1   ))))

(define drop-last
  (λ (E ℓ-1)
    (ind-Nat ℓ-1
             (mot-drop-last E)
             (base-drop-last E)
             (step-drop-last E))))


;; unit-tests (M-C-x to see results in the REPL):


(drop-last Atom 1 (vec:: 'a (vec:: 'b vecnil)))
; (the (Vec Atom 1)
;      (vec:: 'a vecnil))

(drop-last Atom 0 (vec:: 'b vecnil))
; (the (Vec Atom 0)
;      vecnil)


;; Again, due to totality, we can't write or compile
;; or interpret (at run time!) an application of
;; drop-last to an empty vector


;; (drop-last Atom 42 vecnil)
; vecnil requires that the length be zero, not
;  43


;;  ___     _
;; |_ _|_ _| |_ ___ _ _ _ __  ___ _________
;;  | || ' \  _/ -_) '_| '  \/ -_)_ /_ / _ \
;; |___|_||_\__\___|_| |_|_|_\___/__/__\___/


;; Pages 165-168 (Fifth Printing) are not in any
;; chapter. We know they're not in Chapter 7 because
;; the frame numbers start at 1, and the last frame
;; in Chapter 7 is 73. Plus there is a nice picture
;; on Page 164 called "one piece at a time."


;; The frames on these pages are notes on
;; interactive syntax and display format.


;; Because ["the racket REPL is
;; hopeless,"](https://github.com/racket/racket/wiki/The-toplevel-is-hopeless)
;; we can't directly do in Emacs most of the things
;; recommended in the intermezzo. I also verified
;; that they don't work in DrRacket. We can do a
;; little, though, and the results are instructive.


;; I'm commenting them out because the REPL resets
;; the cursor to the output of the TODO lines,
;; forcing me to change buffers and reset the
;; cursor to the end. That's undesirable because
;; I reload this buffer (C-c C-c) frequently.


;; (claim peas-i
;;        (Pi ((n Nat))
;;            (Vec Atom n)))

;; (define peas-i
;;   (λ (n)
;;     (ind-Nat n
;;              (λ (k) (Vec Atom k))       ; motive
;;              vecnil                     ; base
;;              (λ (n-1 ps-1)              ; step
;;                (vec:: TODO TODO)))))


;;   ___ _              _             ___
;;  / __| |_  __ _ _ __| |_ ___ _ _  ( _ )
;; | (__| ' \/ _` | '_ \  _/ -_) '_| / _ \
;;  \___|_||_\__,_| .__/\__\___|_|   \___/
;;                |_|


;; This is a challenging chapter because it's not
;; clear at the start where it's going. I figured it
;; out by reading it and writing about it several
;; times, and the notes below are my current
;; iteration.


;; We'll prove that `(+ 1)` _equals_ `add1`, and
;; then that `incr` _equals_ `add1`. `Equals`, here,
;; is not the same as "the same as," which we
;; already know about from judgments:


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   F o u r   F o r m s
;;  o f   J u d g m e n t
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; 1. ____ is a ____.
;;
;; 2. ____ is the same ____ as ____.
;;
;; 3. ____ is a type [as opposed to an instance]
;;
;; 4. ____ and ____ are the same type.


;; Judgments are for humans; formal statements and
;; proofs of statements are for computers. "Formal"
;; means "machine-checkable." We write a formal
;; statement as a `claim` and a formal proof as a
;; `define`, that is, by exhibiting an instance or
;; witness of the claim. Claims, implicitly, are
;; statements that something exists, so showing an
;; instance is a good proof of a claim like that.


;; To say formally what we mean by `equals`, we
;; introduce a type constructor, `=`, its companion
;; value constructor `same`, and some eliminators
;; for `=`. See [the
;; documentation](https://docs.racket-lang.org/pie/#%28part._.Equality%29)
;; for more.


;; The first claim and proof of equality will look
;; like this:


;; (claim +1=add1
;;        (Π ((n Nat))                  ; Read: for every Nat n,
;;           (= Nat (+ 1 n) (add1 n)))) ; ... this equals that.

;; (define +1=add1                      ; Prove by constructing
;;   (λ (n) (same (add1 n))))           ; a "same" value for it.


;; We'll work up to a proof that `incr` equals
;; `add1`. We'll define `incr` as we go along.


;; Bottoming out in `add1` is a good idea because
;; it's a built-in.


;; We'll use "same as" judgments as human
;; motivations along the way. Remember that two
;; expressions are the same, according to some type,
;; if and only if (iff) their normal forms are
;; identical, up to consistent renaming of their
;; variables.


;; We now have three similar notions in the air: (1)
;; "identical," which is machine checkable, even
;; with consistent renaming of variables [footnote];
;; (2) "same," which we check by judgments and which
;; sometimes means "identical," so can be checked by
;; machine; and (3) "equals," which we are going to
;; show now, but solves problems that checking for
;; identical normal forms cannot solve.


;; footnote:: Checking that two expressions are
;; identical up to consistent renaming is
;; surprisingly tricky, and the greats have
;; published mistakes about it. See [de Bruijn
;; Index](https://en.wikipedia.org/wiki/De_Bruijn_index).


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  P r o v i n g   t h a t   + 1   E q u a l s   a d d 1
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; We start by showing that the normal forms of
;; `(+ 1)` and `add1` are identical (up to
;; consistent renaming of variables). That means
;; they're "the same." Then we'll write that fact up
;; via `=` and `same`, showing that they're `equal`.


;; The later proof that `incr` equals `add1`
;; requires new eliminators for `=`, namely `cong`
;; and `replace`, because the normal forms for these
;; two are not identical (up to consistent renaming
;; of variables).


;; Start with the normal form of `(+ 1)`, which is
;; partial application of `+` to `1`:


;; Recall the definition of `+`:


;; (define +
;;   (λ (n j) ;; Don't use the name n-1 here.
;;     ;;        target base  step  ; the pattern
;;     ;;       |------|----|-------|
;;     (iter-Nat    n     j   step-+ )))


;; where `(define step-+ (λ (n-1) (add1 n-1)))`
;; bottoms out at the built-in `add1`.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N o r m a l   F o r m   o f   ( +   1 )
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Calculate the normal form of `(+ 1)`:


;; (+ 1)
;; (+ (add1 zero))                        destructuring
;; (λ (j)
;;   (iter-Nat (add1 zero) j step-+))     subst. def of +
;; (λ (j)      -----v-----
;;   (step-+       _^__
;;     (iter-Nat   zero    j step-+))     elimination
;; (λ (j)
;;   (add1 ,------- n-1 -------.          subst. def of step-+
;;     (iter-Nat   zero j step-+)))
;;                     /
;;                ----
;;               /
;; (λ (j) (add1 j))                       base case


;; That's the normal form of `(+ 1)`. Remember or
;; bookmark it.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N o r m a l   F o r m   o f   a d d 1
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; The normal form of `(+ 1) is identical to the
;; normal form of `add1` if we wrap `add1` in a
;; minimal function, and we must. The Pie REPL
;; reveals that a naked `add1` doesn't have a normal
;; form:


;; add1
; add1: expected valid Pie name
;   at: add1
;   in: add1


;; But the wrapped `add1` is fine (with a type hint)
;; and is already in normal form -- the Pie REPL
;; can't reduce it any more:


;; (the (→ Nat Nat) (λ (n) (add1 n)))   ; input to REPL
;  (the (→ Nat                          ; response from REPL
;          Nat)
;       (λ (n)
;         (add1 n)))


;; If `add1` were a function, we could use the Final
;; Law of Application (Page 139, Fifth Printing), or
;; even the Initial Law of Application (Page 38,
;; Fifth Printing) to show that `add1` is "the same"
;; as `(λ (n) (add1 n))`.


;; This pattern of wrapping `add1` is exactly like
;; the common need to wrap macros with functions in
;; C and Lisp. We must often do that so we can pass
;; around the functions as values. Macros are not
;; values, but functions _are_ values because they
;; have the constructor λ up top; that's the
;; definition of a value -- it has a constructor up
;; top.


;; Let's call it a day: `(λ (n) (add1 n))` _is_ "the
;; normal form of `add1`".


(the (-> Nat Nat) (λ (n) (add1 n)))     ; input to REPL
; (the (→ Nat                           ; response from REPL
;         Nat)
;      (λ (n)
;        (add1 n)))


;; The easiest way to write something that the REPL
;; reduces to the normal form is `(+ 1)`. You can't
;; present a naked `add1` to the REPL.


(+ 1)                                   ; input to REPL
; (the (→ Nat                           ; response from REPL
;         Nat)
;      (λ (j)
;        (add1 j)))


;; We've now shown that `(+ 1)` and `add1` have
;; identical normal forms (up to renaming), so
;; they're "the same" by Big Box on Page 13. That
;; doesn't mean they're `equal`. So let's write
;; `equal` as a statement -- a `claim` or a type --
;; and its proof as a `define`.


;; Frame 8.23, Page 177 (Fifth Printing):


;; Here is a type that _states_ the equality of
;; `(+ 1 n)` and `(add1 n)`. The statement boils
;; down to stating that the normal forms are
;; identical (up to renaming), hence the same.
;; That's not a proof of equality, but a precise
;; statement of it. We'll need a witness,
;; conveniently packaged in a `define`.


(Π ((n Nat))                            ; input to REPL
   (= Nat (+ 1 n) (add1 n)))
; (the U                                ; response from REPL
;      (Π ((n Nat))
;         (= Nat
;            (add1 n)
;            (add1 n))))


;; The REPL converged the normal forms to
;; `(add1 n)`! They're "the same" by Big Box, Page
;; 13. So we can write the formal proof of the
;; equality statement by defining something that
;; constructs a value by the sole constructor for =,
;; namely _same_.


;; -----------------------------------------------
(claim +1=add1
       (Π ((n Nat))  ; For every Nat, n, ...
          (= Nat (+ 1 n) (add1 n))))

(define +1=add1
  (λ (n) (same (add1 n))))


;; Really, just the fact that the definition
;; satisfies the claim _is_ the proof! Here is the
;; whole magillah without `claim` or `define`, just
;; a type and a witness ("defines are never
;; necessary!" Page 58, Fifth Printing).


(the (Π ((n Nat))                       ; input to REPL
        (= Nat (+ 1 n) (add1 n)))
     (λ (n) (same (add1 n))))
; (the (Π ((n Nat))                     ; response from REPL
;         (= Nat
;            (add1 n)
;            (add1 n)))
;      (λ (n)
;        (same (add1 n))))


;; -+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f   =
;; -+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 174 (Fifth Printing): "An expression
;;
;;     (= X from to)
;;
;; is a type if X is a type, _from_ is an X, and
;; _to_ is an X."


;; When discussing an `=` type expression, call the
;; second argument the FROM of the expression and
;; the third argument the TO of the expression, with
;; the words FROM and TO in all-caps.


;; The FROM and TO might be types or not, but they
;; must be of type X (type X is a U). Therefore, an
;; `(= ...)` is a dependent type because it might
;; depend on things that might not, themselves, be
;; types.


;; Some examples of `=` types for describing
;; equality -- remember, types _describe_ values,
;; but they are also propositions in logic that
;; _state_ that a value satisfying the type exists.


(= Nat (+ 6 7) 13)                      ; input to REPL
; (the U                                ; response from REPL
;      (= Nat 13 13))


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  P r o o f   t h a t   i n c r   E q u a l s   a d d 1
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Here is `incr`:


;; -----------------------------------------------
(claim incr (→ Nat Nat))

(define incr
  (λ (n)
    (iter-Nat n                         ; target
              1                         ; base
              (+ 1))))                  ; step


;; The normal forms of `(+ 1)` and `incr` are not
;; "the same." We'll show so by showing that their
;; normal forms are not identical (up to renaming).
;; Check your hand calculation by computing the
;; normal forms in the REPL:


(+ 1)                                   ; input to REPL
; (the (→ Nat                           ; response from REPL
;         Nat)
;      (λ (j)
;        (add1 j)))
;
incr                                    ; input to REPL
; (the (→ Nat                           ; response from REPL
;         Nat)
;      (λ (n)
;        (iter-Nat n
;                  (the Nat 1)
;                  (λ (j)
;                    (add1 j)))))


;; I made up the following exercise to express the
;; claim -- the statement, the type -- that they're
;; equal, though not the same.


(Π ((n Nat))
   (= Nat (+ 1 n) (incr n)))            ; input to REPL
; (the U                                ; response from REPL
;      (Π ((n Nat))
;         (= Nat
;            (add1 n)
;            (iter-Nat n
;                      (the Nat 1)
;                      (λ (j)
;                        (add1 j))))))


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f   s a m e
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; My edits after incorporating Frame 8.37, Page 179.


;; The expression (same e3) is an (= X e1 e2) if e1,
;; e2, and e3 are each an X and e1 is the same as
;; e2.


;; We've seen that `(+ 1 n)` and `(add1 n)` are the
;; same but `(+ 1 n)` and `(incr n)` are not
;; identical. Can we exhibit a witness in a `same`
;; constructor?


;; Writing a formal type-witness proof of sameness
;; is called _internalizing_ a sameness judgment.


;; Π-expressions are statements of universal
;; quantifications, i.e, "for-every," ∀, statements
;; (Page 187, Fifth Printing). `(→ Y X)` is a
;; shorthand for `(Π ((y Y)) X)` when the name of
;; `Y`'s instance, `y`, is not `needed in `X` (Page
;; 138, Fifth Printing).


;; "By combining Π with =, we can write statements
;; that are true for arbitrary Nats, while we could
;; only make judgments about particular Nats. Here's
;; an example:"


;; Here is a commented-out copy of the formal proof
;; of `+1=add1` above just to remind us.


;; -----------------------------------------------
;; (claim +1=add1
;;        (Π ((n Nat))
;;           (= Nat (+ 1 n) (add1 n))))

;; (define +1=add1
;;   (λ (n) (same (add1 n))))


;; ... proves the statement that for every Nat n,
;; (+ 1 n) equals (add1 n). Equals, here is via the
;; type constructor `=`.


;; But `incr=add1` doesn't prove so easily, as
;; noted. Here is a statement of the proposition,
;; copied from above and attached to a name via
;; `claim`.


;; -----------------------------------------------
(claim incr=add1
       (Π ((n Nat))
          (= Nat (incr n) (add1 n))))


;; This is _harder_ to prove because the normal
;; forms of `(incr n)` and `(add1 n)` are not
;; identical.


;; (define incr=add1
;;   (λ (n)
;;     (same (add1 n))))                ; input to REPL
; The expressions                       ; response from REPL
; (iter-Nat n
;           (the Nat 1)
;           (λ (j)                      ; same as (+ 1)
;             (add1 j)))                ; and add1
; and
; (add1 n)
; are not the same Nat


;; The normal form of (incr n) is
;; (iter-Nat n 1 (+ 1) (we must add a type hint for
;; Pie); _part of it_ is informally the same as
;; `add1` or `(+ 1)`:


(the (→ Nat Nat) (λ (n) (incr n)))      ; input to REPL
; (the (→ Nat                           ; response from REPL
;         Nat)
;      (λ (n)
;        (iter-Nat n
;                  (the Nat 1)
;                  (λ (j)               ; same as add1 or
;                    (add1 j)))))       ; (+ 1)


;; We must figure out how to fish out that part.


;;                  __           ___ __
;;   ___  ___ __ __/ /________ _/ (_) /___ __
;;  / _ \/ -_) // / __/ __/ _ `/ / / __/ // /
;; /_//_/\__/\_,_/\__/_/  \_,_/_/_/\__/\_, /
;;                                    /___/


;; The book goes on a long discourse about
;; neutrality to make needed observations about
;; normal forms.


;; This normal form of (incr n),
;;
;;     (iter-Nat n 1 (+ 1))
;;
;; is neutral, because it's not a value (no
;; constructor up top) and it cannot (yet) be
;; evaluated because of the variable `n`. From Page
;; 182 (Fifth Edition):


;; "Variables that are not defined are neutral. If
;; the target of an eliminator expression [like
;; iter-Nat] is neutral, then the eliminator
;; expression is neutral. _Thus values are not
;; neutral_."


;; This implication needed [a little
;; clarification](https://racket.discourse.group/t/the-little-typer-implicattion-that-values-are-not-neutral/1737)
;; for me. The gist is that neutral variables and
;; neutrally targeted eliminator expressions are
;; _the only_ kinds of neutral expressions. No value
;; can be of either kind. `(add1 n)` though
;; seemingly neutral, is not a neutral expression by
;; because it's not a naked variable and is not a
;; targeted eliminator expression. Its normal form,
;; `(λ (j) (add1 j))`, reported by Pie, is a value
;; with a λ constructor up top.


;; Now, we're going to do a lot of talking about
;; whether neutral expressions are normal. This is
;; the most tricky bit of reasoning in the book
;; through Chapter 8, but we shall exhibit neutral
;; expressions that are not normal because they
;; reduce to values and values can never be neutral.


;; Frame 2.26, Page 40: "Expressions that are not
;; values and cannot yet be evaluated due to a
;; variable are called _neutral_."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N o r m a l   a n d   N e u t r a l
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Frames 8.48-8.49, Page 181 (Fifth Printing): the
;; normal form of `(incr n)`, namely
;; (iter-Nat n 1 (+ 1)), is neutral because it is a
;; neutrally targeted eliminator expression: (1) it
;; is not a value (no constructor up top) and (2) it
;; cannot yet be evaluated due to the variable n.
;; This is normal and neutral.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N o r m a l   b u t   N o t   N e u t r a l
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; (λ (x) (add1 x)), already normal, is not neutral
;; because it's a value with the function
;; constructor λ up top


(the (→ Nat Nat) (λ (x) (add1 x)))      ; input to REPL
; (the (→ Nat                           ; response from REPL
;         Nat)
;      (λ (x)
;        (add1 x)))


;; itself: normal but not neutral


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N e i t h e r   N o r m a l   n o r   N e u t r a l
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


(+ 1)
; (the (→ Nat
;         Nat)
;      (λ (j)
;        (add1 j)))


;; neither neutral nor normal; its normal form is a
;; value thus not neutral.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N e u t r a l   b u t   N o t   N o r m a l
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 183 (Fifth Printing):


;; the neutral expression `(the (→ Nat Nat) f)` is
;; "the same" as `(λ (n) (f n))` by the Laws of λ
;; when `n` does not occur in `f`. `(λ (n) (f n))`
;; is not neutral because it is a value. So `f` is
;; reckoned "neutral but not normal."


;; Page 184, Fifth Printing: Likewise, any neutral
;; `(Pair A D)`, `p`, is not normal because its
;; normal form, `(cons (car p) (cdr p))` is not
;; neutral: it has the constructor `cons` up top.


;; -+-+-+-+-+-+-+-+-+-+-+-+-
;;  B a c k   t o   W o r k
;; -+-+-+-+-+-+-+-+-+-+-+-+-


;; Remember our claim:


;; (claim incr=add1
;;        (Π ((n Nat))
;;           (= Nat (incr n) (add1 n))))


;; Let's try


;; (define incr=add1
;;   (λ (n)
;;     (same (iter-Nat n 1 (+ 1)))))    ; input to REPL
; The expressions                       ; response from REPL
;   (add1 n)
; and
;   (iter-Nat n
;      (the Nat 1)
;      (λ (j)
;        (add1 j)))
; are not the same Nat


;; This fails because the normal form of `(add1 n)`,
;; namely `(λ (n) (add1 n))`, is not neutral because
;; it's a value, but `(iter-Nat n 1 (+ 1))` is
;; neutral even thought it's normal.


;; Check it a couple of more ways:


;; (check-same (→ Nat Nat)
;;             (λ (n) (iter-Nat n 1 (+ 1)))
;;             (λ (n) (add1 n)))        ; input to REPL
; The expressions                       ; response from REPL
;   (λ (n)
;     (iter-Nat n
;        (the Nat 1)
;        (λ (j)
;          (add1 j))))
; and
;   (λ (n)
;     (add1 n))
; are not the same
;   (→ Nat
;     Nat)


;; (check-same (→ Nat Nat)
;;             (λ (n) (iter-Nat n 1 (+ 1)))
;;             (λ (n) (+ 1 n)))         ; input to REPL
; The expressions                       ; response from REPL
;   (λ (n)
;     (iter-Nat n
;        (the Nat 1)
;        (λ (j)
;          (add1 j))))
; and
;   (λ (n)
;     (add1 n))
; are not the same
;   (→ Nat
;     Nat)


;; Socrates, on the left-hand side of every frame,
;; says "try `ind-Nat`." We'll need a target, a
;; base, a motive, and a step.


;; -+-+-+-+-
;;  b a s e
;; -+-+-+-+-


;; Here is a base case that makes an `=` statement
;; about `zero`:


;; -----------------------------------------------
(claim base-incr=add1
       (= Nat (incr 0) (add1 zero)))

(define base-incr=add1
  (same (add1 zero)))


;; -+-+-+-+-+-+-
;;  m o t i v e
;; -+-+-+-+-+-+-


;; Here is a motive that makes an `=` statement
;; about any Nat:


;; -----------------------------------------------
(claim mot-incr=add1                    ; standard
       (→ Nat U))

(define mot-incr=add1
  (λ (k)
    (= Nat (incr k) (add1 k))))


;; -+-+-+-+-
;;  s t e p
;; -+-+-+-+-


;; The step must move us from an `=` statement about
;; Nat k to an `=` statement about `(add1 k)`:


;; The following attempt works, but it considered
;; not ideal for reasons to-be-revealed:


;; (claim step-incr=add1
;;        (Π (( n-1 Nat ))
;;           (→ (mot-incr=add1 n-1)
;;              (mot-incr=add1 (add1 n-1)))))


;; Inline the references to the motive:


;; (claim step-incr=add1
;;        (Π (( n-1 Nat ))
;;           (→ (= Nat
;;                 (incr n-1)
;;                 (add1 n-1))
;;              (= Nat
;;                 (incr (add1 n-1))
;;                 (add1 (add1 n-1))))))


;; Works, but still considered ugly because of lack
;; of parallelism in the last two lines. Without
;; that, we can't easily spot the opportunity to
;; apply `cong`!


;; The following claim is considered ideal because
;; it pulls the `add1` up top in the output of
;; `step-incr=add1`. See Page 188 (Fifth Printing)
;; for a lengthy calculation. This form makes the
;; application of `cong` obvious, but only by
;; applying the pseudo-function `add1`: Letting
;;
;; target be (= Nat
;;              (incr n-1)
;;              (add1 n-1))
;;
;; and `f` "be" `add1`, `(cong target f)` is
;;
;; (= Nat
;;    (add1 (incr n-1))
;;    (add1 (add1 n-1)))


(claim step-incr=add1
       (Π (( n-1 Nat ))
          (→ (= Nat
                (incr n-1)
                (add1 n-1))
             (= Nat
                (add1 (incr n-1))
                (add1 (add1 n-1))))))


;; To prove this claim, i.e., to produce a witness,
;; we introduce `cong` ("congruent"). `cong` is an
;; eliminator for =.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f   c o n g
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 190 (Fifth Printing): If `f `is an `(→ X Y)`
;; [even if only a macro like `add1`] and `target`
;; is an `(= X from to)`, then `(cong target f)` is
;; an `(= Y (f from) (f to))`.


;; This looks like [The Yoneda Lemma](https://en.wikipedia.org/wiki/Yoneda_lemma) to my eyes.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   C o m m a n d m e n t   o f   c o n g
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Show how `cong` eliminates `=`:


;; Page 194 (Fifth Printing): If `x` is an `X` and
;; `f` is an `(→ X Y)`, then
;;
;;     (cong (same x) f)
;;
;; is the same `(= Y (f x) (f x))` as `(same (f x))`


;; In our example, we must transform


;;    (= Nat
;;       (incr n-1)
;;       (add1 n-1))


;; into


;;    (= Nat
;;       (add1 (incr n-1))
;;       (add1 (add1 n-1))))


;; by eliminating =:


(define step-incr=add1
  (λ (n-1)
    (λ (incr=add_n-1)
      (cong incr=add_n-1 (+ 1)))))


;; We're done:


(define incr=add1
  (λ (n)
    (ind-Nat n
             mot-incr=add1
             base-incr=add1
             step-incr=add1)))


;; Frame 8.89, Page 195 (Fifth Printing):


;; Soc: "The interplay between judging sameness and
;; stating equality is at the heart of dependent
;; types. This taste only scratches the surface."


;;   ___ _              _             ___
;;  / __| |_  __ _ _ __| |_ ___ _ _  / _ \
;; | (__| ' \/ _` | '_ \  _/ -_) '_| \_, /
;;  \___|_||_\__,_| .__/\__\___|_|    /_/
;;                |_|


;; TODO


;;   ___ _             _     ___ _            _
;;  / __| |_  ___ __ _| |_  / __| |_  ___ ___| |_
;; | (__| ' \/ -_) _` |  _| \__ \ ' \/ -_) -_)  _|
;;  \___|_||_\___\__,_|\__| |___/_||_\___\___|\__|


;; [The Ultimate Cheat Sheet is
;; here](https://docs.racket-lang.org/pie/#%28part._top%29).
;; It's the official pie documentation. It's
;; refreshingly short and useful.


;; The rest of this Cheat Sheet is my gleanings from
;; "The Little Typer."


;; All page numbers refer to the Fifth Printing.
;; I've gathered together edited transcriptions of
;; the boxed definitions, laws, and commandments
;; according to my own needs. My edits are clearly
;; marked, as are direct quotations from the book.
;; This is a good point to review them all because
;; chapter 8 goes into the weeds with neutral
;; expressions and normal forms.


;; -+-+-+-+-+-+-
;;  V a l u e s
;; -+-+-+-+-+-+-


;; Page 22: "An expression with a constructor [up]
;; top is called a _value_."


;; (add1 0) is a value but (+ 1 0) is not.


;; -+-+-+-+-+-+-+-+-+-+-+-+-
;;  N o r m a l   F o r m s
;; -+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 13: "Given a type, every expression
;; described by that type has a normal form, which
;; the most direct way of writing it. Iff two
;; expressions are the same [according to some
;; type], then they have identical normal forms."


;; This is how Mathematica works: keep rewriting
;; expressions until Mathematica's notion of the
;; normal form is achieved and the expression does
;; not change its syntactical structure by applying
;; any more rules.


;; Frame 1.97, Page 25: "A normal expression has no
;; remaining opportunities for evaluation."


;; I believe this implies that normal forms are
;; unique and that the fact is called The Confluence
;; Theorem.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  V a l u e s   a n d   N o r m a l   F o r m s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 24: "Not every value is a normal form. This
;; is because the arguments [of] a constructor need
;; not be normal. Each expression has only one
;; normal form, but it is sometimes possible to
;; write it as a value[, with a constructor up top,]
;; in more than one way."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N o r m a l   F o r m s   a n d   T y p e s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

;; Frame 1.44, Page 12; also Page 14: "Sameness is
;; always according to a type, so normal forms are
;; also described by a type."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   F i r s t   C o m m a n d m e n t
;;  o f   c o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 15: "Two cons-expressions are the same (Pair
;; A D) if their cars are the same A and their cdrs
;; are the same D. Here, A and D stand for any
;; type[s]."


;; One judges sameness according to a type by
;; writing "two expressions e1 and e2 are the same
;; X," where A is a type. This is a minor variation
;; of a judgment of form 4 (see circa Line 1643).


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N o r m a l   F o r m s   O F   T y p e s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 16: "Every expression that IS a type has a
;; normal form, which is the most direct way of
;; writing that type. Iff two expressions ARE the
;; same type, then they have identical normal
;; forms." (emphasis mine).


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  L a w s   a n d   C o m m a n d m e n t s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page xiii in the Preface: "Laws describe which
;; expressions are meaningful and commandment
;; describe which expressions are the same as others
;; [, with 'same''s having a technical meaning that
;; is spelled out in the Commandments.]"


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  C l a i m s   b e f o r e   D e f i n i t i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  E v a l u a t i o n   &   E x p r e s s i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 25: "In Pie, values are also expressions.
;; Evaluation in Pie finds an expression, not some
;; other kind of thing."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   C o m m a n d m e n t   o f   z e r o
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 26: "zero is the same Nat as zero."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   C o m m a n d m e n t   o f   a d d 1
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 26: "If n is the same Nat as k, then (add1
;; n) is the same Nat as (add1 k)."

;; Frame 100, Page 26: "Two Nat expressions, that
;; are not values, are the same if their values are
;; the same.."


;; This statement implies that evaluation can reduce
;; an expression like (+ 1 0) that is not a value to
;; a value like (add1 0).


;; This statement also implies that sameness
;; pertains to expressions, some of which might not
;; be values.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  D e f i n i t i o n s   a r e   F o r e v e r
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Aka, _immutable_.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  C o n s t r u c t o r s   a n d
;;  E l i m i n a t o r s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 33: "Constructors build values [expressions
;; with a constructor up top], and eliminators take
;; apart values built by constructors."


;; I usually pair elimination with a preceding
;; destructuring. See comments near Line 262 in this
;; document.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  E l i m i n a t i n g   F u n c t i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 34: "Applying a function to arguments _is_
;; the eliminator for functions."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   I n i t i a l   L a w
;;  o f   A p p l i c a t i o n
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 38: "If f is an (→ Y X) and arg is a Y, then
;; (f arg) is an X."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   I n t e r m e d i a t e   L a w
;;  o f   A p p l i c a t i o n
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 100: "
;; If f is a
;;   (Π (( Y U ))
;;     X)
;; and Z is a U, then
;;   (f Z)
;; is an X, where every Y has been consistently
;; replaced by Z."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   F i n a l   L a w
;;  o f   A p p l i c a t i o n
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 139: "
;; If f is a
;;   (Π (( y Y ))
;;     X)
;; and Z is a Y, then
;;   (f z)
;; is an X, where every y has been consistently
;; replaced by z."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   F i n a l   L a w   o f   λ
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 139: "
;; If x is an X when y is a Y, then
;;   (λ (y) x)
;; is a
;;   (Π (( y Y ))
;;     X)."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   Final
;;  F i r s t   C o m m a n d m e n t   o f   λ
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 139: "
;; If two λ-expressions can be made the same
;;   (Π (( y Y ))
;;     X)
;; by consistently renaming their variables,
;; then they are the same."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   I n i t i a l
;;  F i r s t   C o m m a n d m e n t   o f   λ
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 38: "Two λ-expressions that expect the same
;; number of arguments are the same if their bodies
;; are the same after consistently renaming their
;; variables."


;; "Consistent renaming" is a lot more subtle than
;; it sounds because preventing collisions of free
;; and bound variable names in deep expressions is
;; error-prone. Errors have occurred in archival
;; papers by great authors. Look up ["de Bruijn
;; Index"](https://en.wikipedia.org/wiki/De_Bruijn_index)
;; for more info.


;; The Little Typer book sweeps the topic of
;; consistent renaming under the rug of "occur" The
;; Initial Second Commandment of λ below and in The
;; Law of Renaming Variables. We don't need to worry
;; about it much, here, but if one is implements Pie
;; or the λ-calculus, one must be wary.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   I n i t i a l
;;  S e c o n d   C o m m a n d m e n t   o f   λ
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 38: "If f is an (→ Y X) then f is the same
;; (→ Y X) as (λ (y) (f y)) [so] long as y does not
;; occur in f [at any level]."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   F i n a l
;;  S e c o n d   C o m m a n d m e n t   o f   λ
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 140: "
;; If f is a
;;   (Π ((y Y))
;;     X)
;; and y does not occur [at any level] in f, then
;; f is the same as
;;   (λ (y)
;;     (f y))."


;; Page 183: "Commandments such as this one are often
;; called η-rules. These normal forms in which all
;; possible η-rules have been applied to make values
;; are called _η-long normal forms.'"


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f
;;  R e n a m i n g   V a r i a b l e s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 39: "Consistently renaming variables can't
;; change the meaning of anything."


;; This law is a requirement, but doesn't give an
;; algorithm, let alone an efficient one, for
;; consistent renaming. The article cited above on
;; de Bruijn Indices introduces some algorithms for
;; consistent renaming.


;;    _  __         __           __
;;   / |/ /__ __ __/ /________ _/ /
;;  /    / -_) // / __/ __/ _ `/ /
;; /_/|_/\__/\_,_/\__/_/  \_,_/_/
;;    ____                           _
;;   / __/_ __ ___  _______ ___ ___ (_)__  ___  ___
;;  / _/ \ \ // _ \/ __/ -_|_-<(_-</ / _ \/ _ \(_-<
;; /___//_\_\/ .__/_/  \__/___/___/_/\___/_//_/___/
;;          /_/


;; This deserves a big heading because it's critical
;; to Chapter 8.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   C o m m a n d m e n t   o f
;;  N e u t r a l   E x p r e s s i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 42: "Neutral expressions ... written
;; identically are the same, _no matter their
;; type_."


;; We must learn about neutral expressions. Rewind
;; to Chapter 2.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N e u t r a l   E x p r e s s i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Frame 2.26, Page 40: "Expressions that are not
;; values and cannot yet be evaluated due to a
;; variable are called _neutral_."


;; This means that (cdr y) is a neutral expression
;; because it is not a value because cdr is not a
;; constructor, but an eliminator. However (λ (y)
;; (cdr y)) is not a neutral expression because it
;; IS a value because λ is a constructor.


;; Frame 2.27, Page 40: "... two occurrences of a
;; variable cannot be replaced by values that are
;; not the same."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   a n d   C o m m a n d m e n t
;;  o f   d e f i n e
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 43: "Following
;;   (claim _name_ X) and (define _name_ _expr_)
;; if
;;   _expr_ is an X                     ; judg. 1
;; then
;;   _name_ is an X                     ; judg. 1
;; and
;;   _name_ is the same X as _expr_     ; judg. 2


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   S e c o n d   C o m m a n d m e n t
;;  o f   c o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 44: "If p is a (Pair A D) [j1] then it is
;; the same (Pair A D) as (cons (car p) (cdr p))
;; [j2]."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N a m e s   i n   D e f i n i t i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 46: "In Pie, only names that are not already
;; used, whether for constructors, eliminators, or
;; previous definitions, can be used with _claim_ or
;; _define_."


;; -+-+-+-+-+-+-+-+-+-+-+-
;;  T y p e   V a l u e s
;; -+-+-+-+-+-+-+-+-+-+-+-


;; Page 53: "An expression that is described by a
;; type is a value when it has a constructor [up]
;; top. Similarly, an expression that IS a type is a
;; value when it has a type constructor [up] top."


;; Type constructors are things like Nat, Atom, Pair,
;; →, and U.


;; (claim foo54 U)
; cons requires a Pair or Σ type, but was used as a U

(claim foo54 (Pair U U))

(define foo54 (cons Atom Atom))


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  E v e r y   U   i s   a   T y p e
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 55: "Every expression described by U is a
;; type, but not every type is described by U."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   C o m m a n d m e n t   o f   t h e
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 66: "If X is a type and e is an X, then
;;   (the X e)
;; is the same X as e."


;; -+-+-+-+-+-+-+-+-
;;  S a m e n e s s
;; -+-+-+-+-+-+-+-+-


;; Page 70: "If a 'same-as' chart could show that
;; two expressions are the same, then this fact can
;; be used anywhere without further justification.
;; 'Same-As' charts are only to help build
;; understanding."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T o t a l   F u n c t i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 71: "A function that always assigns a value
;; to _every_ possible argument is called a _total
;; function_.


;; Skipping iter-Nat, rec-Nat, which-Nat, rec-List.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f   L i s t
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 110: "If E is a type, then (List E) is a
;; type."


;; Page 120: "All ... entries in a list must have
;; the same type."


;; Skipping Page 131.


;; -+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f   Π
;; -+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 136: "
;; The expression
;;   (Π (( y Y ))
;;     X)
;; is a type when Y is a type, and X is a type if y
;; is a Y."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  U s e   a   M o r e   S p e c i f i c   T y p e
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 137: "Make a function total by using a more
;; specific type to rule out unwanted arguments."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  U s e   i n d - N a t
;;  f o r   D e p e n d e n t   T y p e s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 145: "Use ind-Nat instead of rec-Nat when
;; the [type of the] rec-Nat or ind-Nat expression
;; depends on the target Nat. The [type of the]
;; ind-Nat expression is the motive applied to the
;; target."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f   i n d - N a t
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; See also "claim iN" around line 948 above.


;; Page 147: "
;; If target is a Nat, mot is an
;;   (→ Nat U)
;; base is a (mot zero) and step is a
;;   (Π ((n-1 Nat))
;;     (→ (mot n-1)
;;     (mot (add1 n-1))))
;; then
;;   (ind-Nat target mot base step)
;; is a
;;   (mot target)."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  I n d u c t i o n
;;  o n   N a t u r a l   N u m b e r s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 149: "Building a value for any natural
;; number by giving a value for zero and a way to
;; transform a value for [n-1 into a value for n] is
;; called _induction on natural numbers."
