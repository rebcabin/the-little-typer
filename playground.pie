#lang pie


'spinach

(the (Pair Atom Atom)
  (cons 'spinach 'cauliflower))

(the Atom (the Atom 'pie))


;; -+-+-+-+-+-+-+-+-+-
;;  w h i c h - N a t
;; -+-+-+-+-+-+-+-+-+-


;; which-Nat has type
;; (Π ((E U))
;;   (→ target:N base:E step:(→ N E) E))
;;
;; or, less noisily
;;
;; (Π ((E U))
;;   (→ N E (→ N E) E))

;; The base and the output of step must have the same
;; type (E U). E can be anything -- Atom or Nat, for
;; instance, but it must be the same on both branches
;; of which-Nat.


;; A good name for the argument (parameter?) of
;; step is n-1 because step is called when
;; target == n == (add1 n-1).
;;
;; A parameter is a name for an argument. What is
;; the name of a parameter (you answer)?
;;
;; SPOILER: Parameters inhabit a space of symbolic
;; calculation inside the compiler or its run-time,
;; representative functions like add1. Names of
;; parameters only appear in the implementations of
;; the compiler or its run-time representative
;; functions, where they may stand for arbitrary
;; parameters. At the user's level. parameters are
;; names for arguments, where they may stand for
;; arbitrary argument values. Recall that values are
;; expressions with constructors up top (in first
;; positions in parenthesized expressions).

;; (which-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then which-Nat = (step n-1)


(which-Nat zero 'naught (λ (n-1) 'more))
(which-Nat 4    'naught (λ (n-1) 'three))


;; Show how rec-Nat can mimic this behavior, i.e., by
;; the step's ignoring both its arguments:


(rec-Nat zero 'rec-naught (λ (n-1 r) 'rec-more))
(rec-Nat 4    'rec-naught (λ (n-1 r) 'rec-three))


;; The book writes ignored arguments in dim font. I
;; think we don't need to bother much about that.
;; But we might sometimes write _ or foo_ with a _
;; suffix for ignored arguments.


;; Later, we'll see that by step's ignoring one of
;; its arguments, namely r, the recursive
;; computation, rec-Nat simulates iter-Nat.


;;   ___ _              _             ____
;;  / __| |_  __ _ _ __| |_ ___ _ _  |__ /
;; | (__| ' \/ _` | '_ \  _/ -_) '_|  |_ \
;;  \___|_||_\__,_| .__/\__\___|_|   |___/
;;                |_|


;; Frame 3.23


;;        target base      step
;;       |------|----|----------------|
(iter-Nat    5     3  (λ (k) (add1 k)))


;; Can't go to point-free form, i.e.,
;; cannot change add1 for (λ (k) (add1 k)).
;;
;; (iter-Nat 5 3 add1) ;
;; /Users/brian/Documents/GitHub/the-little-typer/playground.pie:17:14:
;; add1: expected valid Pie name
;   at: add1
;   in: add1


;; (iter-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then iter-Nat ==
;; (step
;;    (iter-Nat n-1 base step))


;; iter-Nat has type
;;
;; (Π ((E U))
;;   (→ N E (→ N E) E))
;;
;; same as the type of which-Nat. The difference
;; between the two is that iter-Nat calls iter-Nat
;; for the argument of step. User-defined code must
;; not recurse, but this system-defined routine can.


;; (+ 2 3) ;; ; Unknown variable +


(claim step-+
       (→ Nat Nat))

(define step-+
  (λ (n-1) (add1 n-1)))


(claim + (→ Nat Nat Nat))

(define +
  (λ (n j) ;; Don't need the name n-1 here.
    ;;        target base  step
    ;;       |------|----|-------|
    (iter-Nat    n     j   step-+)))


;; Frame 3.28, sort-of


;; (which-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then which-Nat = (step n-1)


;; -+-+-+-+-+-+-+-+-+-+-+-
;;  e l i m i n a t i o n
;; -+-+-+-+-+-+-+-+-+-+-+-


;; The process of replacing (add1 n-1) with n-1 is
;; called "elimination" because it strips off --
;; eliminates -- the value constructor add1.
;; Selection (which-Nat), iteration (iter-Nat), and
;; recursion occur in a backwards kind of way, by
;; eliminating toward zero. This sequential
;; elimination *builds up* an expression that is
;; eventually evaluated to the unique normal form --
;; the "most direct" form.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  d e s t r u c t u r i n g
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-


;; The process of noticing that n == (add1 n-1) is
;; called "destructuring," a term not in The Little
;; Typer, but borrowed from Clojure. It defines the
;; argument and parameter n-1 by eliminating n-1
;; from (add1 n-1)l

;; (iter-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then iter-Nat ==
;;             elimination
;; (step       |---------|
;;    (iter-Nat    n-1    base step))

(+ 2 3) ; 1. ...

;; 2.     (iter-Nat     2    3 step-+)
;; 3.     (iter-Nat (add1 1) 3 step-+)    destructuring
;; 4. (step-+            /                elimination
;;        (iter-Nat     1    3 step-+))
;; 5. (step-+       ____^___
;;        (iter-Nat (add1 0) 3 step-+))   destructuring
;; 6. (step-+            /                elimination
;;      (step-+         |
;;        (iter-Nat     0    3 step-+)))
;;        -------------------v--------
;; 7. (step-+                             subst. base
;;      (step-+              3))
;; ~~~> 5                                 evaluation


;; Here is something I made up to show that rec-Nat
;; is at least as strong as iter-Nat.


;; (rec-Nat target base step) == base if
;; target == 0 else if target == (add1 n-1)
;; then rec-Nat ==
;; (step n-1                              nota bene
;;    (rec-Nat n-1 base step))            elimination

(claim sr+
       (→ Nat Nat Nat))

(define sr+
  (λ (n-1 r) (add1 n-1))) ;               ignore r

(rec-Nat 2 3 sr+) ; 1. ...

;; 2.     (rec-Nat     2    3 sr+)
;;                 ____^___
;; 3.     (rec-Nat (add1 1) 3 sr+)        destructuring
;; 4. (sr+ 1            /                 elimination
;;        (rec-Nat     1    3 sr+))
;; 5. (sr+ 1       ____^___               destructuring
;;        (rec-Nat (add1 0) 3 sr+))
;; 6. (sr+ 0            /                 elimination
;;      (sr+ 0         |
;;        (rec-Nat     0    3 sr+)))
;;        ------------------v-----        subst. base
;; 7. (sr+ 0
;;      (sr+ 0              3))
;; ~~~> 5                                 evaluation


;; -+-+-+-+-+-
;;  g a u s s
;; -+-+-+-+-+-


;; Here is an example that must use both arguments
;; to rec-Nat.


(claim step-gauss
       (→ Nat Nat Nat))

(define step-gauss
  (λ (n-1 rg)
    (+ (add1 n-1) rg)))


(claim gauss
       (→ Nat Nat))

(define gauss
  (λ (n) ; Don't name this argument n-1
    (rec-Nat n ; "target": if zero, return ...
             0 ; "base": else, if it's (add1 n-1)
             ;; return
             ;; (step-gauss
             ;;   (rec-Nat n-1
             ;;            base
             ;;            step-gauss)
             step-gauss)))

(gauss 3) ; 1. ...

;; let rN == rec-Nat, sg == step-gauss, a1 == add1
;; (rN    0   b s) ~~> b
;; (rN (a1 n) b s) ~~> (s n (rN n b s))

;; 2.       (rN    3   0 sg)
;;              ___^__
;; 3.       (rN (a1 2) 0 sg)              destructuring
;; 4. (sg 2        /                      elimination
;;          (rN    2   0 sg))
;; 5. (sg 2     ___^__
;;          (rN (a1 1) 0 sg))             destructuring
;; 6. (sg 2        /                      elimination
;;      (sg 1      |
;;          (rN    1   0 sg)))
;; 6. (sg 2        |
;;      (sg 1   ___^__
;;          (rN (a1 0) 0 sg)))            destructuring
;; 7. (sg 2        /                      elimination
;;      (sg 1      |
;;        (sg 0    |
;;          (rN    0   0 sg))))
;; 8. (sg 2 -------v--------
;;      (sg 1      |
;;        (sg 0    0)))                   subst. base
;; 9. (sg 2 (sg 1 (+ (add1 0) 0)))        apply +, incl.
;; A. (sg 2 (sg 1 1))                     multiple
;; B. (sg 2 (+ (add1 1) 1))               steps not
;; C. (sg 2 3)                            exploded here
;; D. (+ (add1 2) 3)
;; E. 6


;;   ___ _              _             _ _
;;  / __| |_  __ _ _ __| |_ ___ _ _  | | |
;; | (__| ' \/ _` | '_ \  _/ -_) '_| |_  _|
;;  \___|_||_\__,_| .__/\__\___|_|     |_|
;;                |_|


;; (claim foo (→ A D))
;; page 98:  ~" → is not up to the job "~


;; -+-+-+-+-
;;  f l i p
;; -+-+-+-+-


(claim flip
       (Π ((A U) (D U))
          (→ (Pair A D)
              (Pair D A))))

(define flip
  (λ (A D)
    (λ (p)
      (cons (cdr p) (car p)))))

(flip Nat Nat)

((flip Nat Atom) (cons 17 'apple))

((flip Nat Nat) (cons 2 3))


(claim elim-Pair
       (Π ((A U) (D U) (X U))
          (→ (Pair A D)
              (→ A D X)
              X)))

(define elim-Pair
  (λ (A D X)
    (λ (p f)
      (f (car p) (cdr p)))))

elim-Pair


;; -+-+-+-+-+-+-+-+-
;;  k a r ,   k d r
;; -+-+-+-+-+-+-+-+-


(claim kar
       (→ (Pair Nat Nat) Nat))

(define kar
  (λ (p)
    (elim-Pair Nat Nat Nat
               p
               (λ (a d) a))))

kar

(kar (cons 2 3))


(claim kdr
       (→ (Pair Nat Nat) Nat))

(define kdr
  (λ (pn)
    (elim-Pair Nat Nat Nat
               pn
               (λ (a d) d))))

(kdr (cons 2 3))


;; Frame 4.50


;; -+-+-+-+-
;;  t w i n
;; -+-+-+-+-


(claim twin
       (Π ((Y U))
          (→ Y (Pair Y Y))))

(define twin
  (λ (Y)
    (λ (x)
      (cons x x))))

((twin Atom) 'pew)


;;   ___ _              _             ___
;;  / __| |_  __ _ _ __| |_ ___ _ _  | __|
;; | (__| ' \/ _` | '_ \  _/ -_) '_| |__ \
;;  \___|_||_\__,_| .__/\__\___|_|   |___/
;;                |_|


;; Frame 5.31


(claim toppings (List Atom))

(define toppings
  (:: 'potato (:: 'butter nil)))

(claim condiments (List Atom))

(define condiments
  (:: 'chives
      (:: 'mayonnaise nil)))


;; -+-+-+-+-+-+-
;;  l e n g t h
;; -+-+-+-+-+-+-


(claim step-length
       (Π ((E U))
          (→ E (List E) Nat
              Nat)))

(define step-length
  (λ (E)
    (λ (e es length-es)
      (add1 length-es))))


(claim length
       (Π ((E U))
          (→ (List E)
              Nat)))

(define length
  (λ (E)
    (λ (es)
      (rec-List es 0 (step-length E)))))


;; Frame 5.42


(claim length-Atom
       (→ (List Atom) Nat))

(define length-Atom
  (length Atom))


;; Frame 5.45


;; -+-+-+-+-+-+-
;;  a p p e n d
;; -+-+-+-+-+-+-


(claim step-append
       (Π ((E U))
          (→ E (List E) (List E)
              (List E))))

(define step-append
  (λ (E)
    (λ (e es append-es)
      (:: e append-es))))


(claim append
       (Π ((E U))
          (→ (List E) (List E)
              (List E))))

(define append
  (λ (E)
    (λ (start end)
      (rec-List start end (step-append E)))))

((append Nat) nil nil)
(append Nat nil nil) ; Everything's curried.


(claim append-Nat
       (→ (List Nat) (List Nat)
           (List Nat)))

(define append-Nat
  (append Nat))


(append-Nat (:: 1 nil) nil)
(append-Nat nil (:: 2 nil))
(append-Nat (:: 1 nil) (:: 2 nil))


;; -+-+-+-+-+-+-+-
;;  r e v e r s e
;; -+-+-+-+-+-+-+-


(claim snoc
       (Π ((E U))
          (→ (List E) E
              (List E))))

(define snoc
  (λ (E)
    (λ (start e)
      (append E start (:: e nil)))))

;; illegal! (snoc Nat nil nil)

(snoc Nat nil 1)
(snoc Nat (:: 1 nil) 2)


(claim step-reverse
       (Π ((E U))
          (→ E (List E) (List E)
              (List E))))

(define step-reverse
  (λ (E)
    (λ (e es reversed)
      (snoc E reversed e))))


(claim reverse
       (Π ((E U))
          (→ (List E) (List E))))

;; I first wrote the "nil" below without peeking at
;; the answer. But they snuck one in on me, too
;; clever by half!

(define reverse
  (λ (E)
    (λ (es)
      (rec-List es
                (the (List E) nil)
                ;; See sneaky footnote page 125!
                (step-reverse E)))))

(reverse Nat nil)
(reverse Nat (:: 1 nil))
(reverse Nat (:: 2 (:: 1 nil)))


;;   ___ _              _              __
;;  / __| |_  __ _ _ __| |_ ___ _ _   / /
;; | (__| ' \/ _` | '_ \  _/ -_) '_| / _ \
;;  \___|_||_\__,_| .__/\__\___|_|   \___/
;;                |_|


;; two type expressions:


(Vec Atom zero)
(Vec Atom (add1 zero))


;; an instance expression (The Little Typer does
;; not use the word "instance," but I use it to
;; mean a value that is not, itself, a type):


(the (Vec Atom zero) vecnil)


(claim first-of-one
       (Π ((E U))
          (→ (Vec E 1) E)))

(define first-of-one
  (λ (E)
    (λ (es)
      (head es))))

(first-of-one Atom (vec:: 'shiitake vecnil))


;; See https://stackoverflow.com/questions/75516108/vec-in-the-little-typer/75516109#75516109

(the (Vec Atom 1) (vec:: 'shiitake vecnil))
(the (Vec Atom 1) (vec:: (the Atom 'shiitake) vecnil))
(the (Vec Atom 1) (vec:: (the Atom 'shiitake)
                         (the (Vec Atom zero) vecnil)))
(the (Vec Atom 1) (vec:: 'shiitake
                         (the (Vec Atom zero) vecnil)))


;; -+-+-+-+-+-
;;  f i r s t
;; -+-+-+-+-+-


;; Frames 6.34 through 6.37


;; This version of first requires a Nat argument,
;; ℓ-1, that is one fewer than the length of the
;; Vec. The argument must have this form so that
;; -first- be a total function; so that neither its
;; input nor its output may ever be vecnil, that is,
;; the sole (Vec E 0). -First- guarantees totality
;; by destructuring ℓ-1 into (add1 ℓ-1), which may
;; never be zero.


(claim first
       (Π ((E U)
           (ℓ-1 Nat))
          (→ (Vec E (add1 ℓ-1)) E)))

(define first
  (λ (E ℓ-1)
    (λ (es)
      (head es))))

(first Atom 2 (vec:: 'a (vec:: 'b (vec:: 'c vecnil))))
(first Atom 0 (vec:: 'a vecnil))


;;   ___ _              _             ____
;;  / __| |_  __ _ _ __| |_ ___ _ _  |__  |
;; | (__| ' \/ _` | '_ \  _/ -_) '_|   / /
;;  \___|_||_\__,_| .__/\__\___|_|    /_/
;;                |_|


;; (define peas
;;


;; Frame 7.28


(claim base-last
       (Π ((E U))
          (→ (Vec E (add1 zero)) E)))

(define base-last
  (λ (E)
    (λ (es)
      (head es))))


(claim mot-last
       (→ U Nat U))

(define mot-last
  (λ (E k)
    (→ (Vec E (add1 k)) E)))


(mot-last Atom zero)


(Vec U zero)
(the (Vec U zero) vecnil)


(claim step-last
       (Π ((E U)
           (ℓ-1 Nat))
          (→ (mot-last E ℓ-1)
             (mot-last E (add1 ℓ-1)))))

(define step-last
  (λ (E ℓ-1)
    (λ (last-ℓ-1)
      (λ (es)
        (last-ℓ-1 (tail es))))))


(claim last
       (Π ((E U)
           (ℓ-1 Nat))
          (→ (Vec E (add1 ℓ-1)) E)))

(define last
  (λ (E ℓ-1)
    (ind-Nat ℓ-1
             (mot-last E)
             (base-last E)
             (step-last E))))

(last Atom 1 (vec:: 'a (vec:: 'b vecnil)))
