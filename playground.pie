#lang pie  ;; Racket support this language as a
           ;; package.


;;   ___ _                _   __       ___
;;  / __| |_  _ __ ___   / | / _|___  |_  )
;; | (__| ' \| '_ (_-<_  | | > _|_ _|  / /
;;  \___|_||_| .__/__(_) |_| \_____|  /___|
;;           |_|


;; In Emacs racket-mode, C-c C-c sends the whole
;; file to the racket interpreter. C-M-x sends the
;; s-exp that surrounds the cursor, just as with
;; CIDER in Clojure-mode.


;; Alternatively, if you don't want to set up Emacs
;; for racket, load this file into DrRacket and play
;; around. DrRacket comes for free with [the racket
;; distribution](https://download.racket-lang.org/).
;; Install the distribution, type `raco kg install
;; pie` at the terminal, launch `DrRacket` and party
;; on. DrRacket is a fine IDE if you can stand
;; imperfect Emacs key-binding emulation (I can't;
;; too many decades of muscle memory!)


;; Mostly, I leave two blank lines between things. I
;; leave one blank line between a `claim` and its
;; matching `define`. Writing these pairs _feels
;; like_ writing Haskell. I also sometimes leave a
;; single blank line between a definition and its
;; unit tests. I'm not religious about any of that.


'spinach


(the (Pair Atom Atom)
  (cons 'spinach 'cauliflower))


(the Atom (the Atom 'pie))


;; -+-+-+-+-+-+-+-+-+-
;;  w h i c h - N a t
;; -+-+-+-+-+-+-+-+-+-


;; which-Nat has type
;; (Π ((E U))
;;   (→ target:N base:E step:(→ N E) E))
;;
;; or, less noisily
;;
;; (Π ((E U))
;;   (→ N E (→ N E) E))


;; The base and the output of step must have the same
;; type (E U). E can be anything -- Atom or Nat, for
;; instance, but it must be the same on both branches
;; of which-Nat.


;; Here is pseudocode for which-Nat:


;; (which-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then which-Nat = (step n-1)


;; A good name for the argument (parameter?) of step
;; is n-1 because step is called with n-1 when
;; target == n == (add1 n-1).


;; A parameter is a name for an argument. What is
;; the name of a parameter (your answer)?


;; SPOILER: Parameters inhabit a space of symbolic
;; calculation inside the compiler or its run-time,
;; representative functions like add1. Names of
;; parameters only appear in the implementations of
;; the compiler or its run-time representative
;; functions, where they may stand for arbitrary
;; parameters. At the user's level. parameters are
;; names for arguments, where they may stand for
;; arbitrary argument values. Recall that values are
;; expressions with constructors up top (in first
;; positions in parenthesized expressions).


(which-Nat zero 'naught (λ (n-1) 'more))
(which-Nat 4    'naught (λ (n-1) 'three))


;; I made up the following to show how rec-Nat can
;; mimic the behavior of which-Nat, i.e., by the
;; step's ignoring both its arguments:


(rec-Nat zero 'rec-naught (λ (n-1 r) 'rec-more))
(rec-Nat 4    'rec-naught (λ (n-1 r) 'rec-three))


;; Notice that rec-Nat "destructures" its argument
;; into (add1 n-1) and then "eliminates" add1 before
;; handing n-1 to the step function, (λ (n-1 r)
;; 'some-atom). We write more about destructuring
;; and elimination below.


;; The book writes _ignored arguments_ in dim font.
;; I think one need not bother much about that. But
;; one might sometimes write _ or foo_ with a _
;; suffix for ignored arguments. Lots of programming
;; languages follow that convention, sometimes
;; allowing multiple instances of _ without
;; collision.


;; Later, we'll see that by step's ignoring one of
;; its arguments, namely r, the recursive
;; computation, rec-Nat simulates iter-Nat.


;;   ___ _              _             ____
;;  / __| |_  __ _ _ __| |_ ___ _ _  |__ /
;; | (__| ' \/ _` | '_ \  _/ -_) '_|  |_ \
;;  \___|_||_\__,_| .__/\__\___|_|   |___/
;;                |_|


;; Frame 3.23


;; All these functions follow a pattern, with
;; parameters target, base, and step.


;;        target base      step
;;       |------|----|----------------|
(iter-Nat    5     3  (λ (k) (add1 k)))


;; Discovery about pie (the language of this file).
;; Can't go to point-free form, i.e., cannot use
;; add1 for (λ (k) (add1 k)).
;;
;; (iter-Nat 5 3 add1) ;
;; .../the-little-typer/playground.pie:17:14:
;; add1: expected valid Pie name
;   at: add1
;   in: add1


;; pseudocode for iter-Nat


;; (iter-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then iter-Nat ==
;; (step
;;    (iter-Nat n-1 base step))


;; iter-Nat has type
;;
;; (Π ((E U))
;;   (→ N E (→ N E) E))
;;
;; same as the type of which-Nat. The difference
;; between the two is that iter-Nat calls iter-Nat
;; for the argument of step. User-defined code must
;; not recurse, but this system-defined routine can.


;; (+ 2 3) ;; ; Unknown variable +


(claim step-+
       (→ Nat Nat))

(define step-+
  (λ (n-1) (add1 n-1)))


(claim + (→ Nat Nat Nat))

(define +
  (λ (n j) ;; Don't use the name n-1 here.
    ;;        target base  step  ; the pattern
    ;;       |------|----|-------|
    (iter-Nat    n     j   step-+)))


;; Frame 3.28, sort-of


;; reminder of the pseudocode of which-Nat:


;; (which-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then which-Nat = (step n-1)


;; -+-+-+-+-+-+-+-+-+-+-+-
;;  e l i m i n a t i o n
;; -+-+-+-+-+-+-+-+-+-+-+-


;; The process of replacing (add1 n-1) with n-1 is
;; called "elimination" because it strips off --
;; eliminates -- the value constructor add1.
;; Selection (which-Nat), iteration (iter-Nat), and
;; recursion (rec-Nat) occur in a backwards kind of
;; way, by eliminating toward zero. One says
;; "backwards" because one's prior experience with
;; recursion and iteration probably has one starting
;; with some big Nat and _subtracting_ 1 from it by
;; an arithmetic process before recursing. Here, in
;; The Little Typer, we instead destructure larger
;; numbers n into smaller ones (add1 n-1) by writing
;; out the _addition_ that "must have taken place."
;; The effect is the same, but preserves type
;; information here. This kind of reckoning is
;; probably best in any implementation of a type
;; system.


;; Sequential deconstruction and elimination *build
;; up* an expression of smaller Nats. The expression
;; that is eventually evaluated to the unique normal
;; form -- the "most direct" form.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  d e s t r u c t u r i n g
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-


;; The process of noticing that n == (add1 n-1) is
;; "destructuring," a term not in The Little Typer.
;; I borrowed it from Clojure. It defines the
;; argument n-1 by setting up later elimination of
;; n-1 from (add1 n-1).


;; (iter-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;;                               |-------------|
;;                                destructuring
;; then iter-Nat ==        ______/
;;                        /
;;             elimination
;; (step       |---------|
;;    (iter-Nat    n-1    base step))


;; Here is a "same-chart" for "(+ 2 3)." I assume we
;; understand "subst.", i.e., substitution, without
;; further explanation:


(+ 2 3) ; 1. ...                          how? why?
;; 2.     (iter-Nat     2    3 step-+)    subst. def
;; 3.     (iter-Nat (add1 1) 3 step-+)    destructuring
;; 4. (step-+            /                elimination
;;        (iter-Nat     1    3 step-+))
;; 5. (step-+       ____^___
;;        (iter-Nat (add1 0) 3 step-+))   destructuring
;; 6. (step-+            /                elimination
;;      (step-+         |
;;        (iter-Nat     0    3 step-+)))
;;        -------------------v--------
;; 7. (step-+                |            subst. base
;;      (step-+              3))
;; ~~~> 5                                 evaluation


;; Here is something I made up to show that rec-Nat
;; is at least as strong as iter-Nat.


;; (rec-Nat target base step) == base if
;; target == 0 else if target == (add1 n-1)
;; then rec-Nat ==
;; (step n-1                              nota bene
;;    (rec-Nat n-1 base step))            elimination

(claim sr+
       (→ Nat Nat Nat))

(define sr+
  (λ (n-1 r) (add1 n-1))) ;               ignore r


(rec-Nat 2 3 sr+) ; 1. ...
;; 2.     (rec-Nat     2    3 sr+)        subst. def
;;                 ____^___
;; 3.     (rec-Nat (add1 1) 3 sr+)        destructuring
;; 4. (sr+ 1            /                 elimination
;;        (rec-Nat     1    3 sr+))
;; 5. (sr+ 1       ____^___               destructuring
;;        (rec-Nat (add1 0) 3 sr+))
;; 6. (sr+ 0            /                 elimination
;;      (sr+ 0         |
;;        (rec-Nat     0    3 sr+)))
;;        ------------------v-----        subst. base
;; 7. (sr+ 0                |
;;      (sr+ 0              3))
;; ~~~> 5                                 evaluation


;; -+-+-+-+-+-
;;  g a u s s
;; -+-+-+-+-+-


;; Here is an example rec-Nat stepper that uses both
;; arguments that rec-Nat gives it:


(claim step-gauss
       (→ Nat Nat
          Nat))

(define step-gauss
  (λ (n-1 rg)
    (+ (add1 n-1) rg)))


(claim gauss
       (→ Nat Nat))

(define gauss
  (λ (n) ; Don't name this argument n-1
    (rec-Nat n ; "target": if zero, return ...
             0 ; "base": else, if it's (add1 n-1)
             ;; return
             ;; (step-gauss
             ;;   (rec-Nat n-1
             ;;            base
             ;;            step-gauss)
             step-gauss)))


;; Less noisy pseudocode:


;; letting rN == rec-Nat, s == some-stepper, a1 == add1
;; claim s (→ Nat Nat Nat)
;; (rN     0    b s) ~~> b
;; (rN (a1 n-1) b s) ~~> (s n-1 (rN n-1 b s))


(gauss 3) ; 1. ...
;; 2.       (rN    3   0 sg)              subst. def
;;              ___^__
;; 3.       (rN (a1 2) 0 sg)              destructuring
;; 4. (sg 2        /                      elimination
;;          (rN    2   0 sg))
;; 5. (sg 2     ___^__
;;          (rN (a1 1) 0 sg))             destructuring
;; 6. (sg 2        /                      elimination
;;      (sg 1      |
;;          (rN    1   0 sg)))
;; 6. (sg 2        |
;;      (sg 1   ___^__
;;          (rN (a1 0) 0 sg)))            destructuring
;; 7. (sg 2        /                      elimination
;;      (sg 1      |
;;        (sg 0    |
;;          (rN    0   0 sg))))
;; 8. (sg 2 -------v--------
;;      (sg 1      |
;;        (sg 0    0)))                   subst. base
;; 9. (sg 2 (sg 1 (+ (add1 0) 0)))        apply +,
;; A. (sg 2 (sg 1 1))                     including
;; B. (sg 2 (+ (add1 1) 1))               multiple
;; C. (sg 2 3)                            steps not
;; D. (+ (add1 2) 3)                      exploded here
;; E. 6


;;   ___ _              _             _ _
;;  / __| |_  __ _ _ __| |_ ___ _ _  | | |
;; | (__| ' \/ _` | '_ \  _/ -_) '_| |_  _|
;;  \___|_||_\__,_| .__/\__\___|_|     |_|
;;                |_|


;; This chapter is mostly about the miniature
;; calculus on types, a calculus effected by Π. I
;; assume this is easy, so I don't talk much, just
;; show some examples. In Emacs, type M-C-x with the
;; cursor in an example to see its value in the
;; pie/racket interpreter.


;; (claim foo (→ A D))
;; page 98:  ~" → is not up to the job "~


;; -+-+-+-+-
;;  f l i p
;; -+-+-+-+-


(claim flip
       (Π ((A U) (D U))
          (→ (Pair A D)
              (Pair D A))))

(define flip
  (λ (A D)
    (λ (p)
      (cons (cdr p) (car p)))))

(flip Nat Nat)

((flip Nat Atom) (cons 17 'apple))

((flip Nat Nat) (cons 2 3))


(claim elim-Pair
       (Π ((A U) (D U) (X U))
          (→ (Pair A D)
              (→ A D X)
              X)))

(define elim-Pair
  (λ (A D X)
    (λ (p f)
      (f (car p) (cdr p)))))

elim-Pair


;; -+-+-+-+-+-+-+-+-
;;  k a r ,   k d r
;; -+-+-+-+-+-+-+-+-


;; These kar and kdr functions are specialized for
;; Nats. kar and kdr are probably lousy names for
;; them, but go with them just to exit the chapter.
;; `elim-pair` is not specialized, so bracket the
;; function-calls appropriately.


(claim kar
       (→ (Pair Nat Nat) Nat))

(define kar
  (λ (p)
    ((elim-Pair Nat Nat Nat) ; specialized on Nats
               p
               (λ (a d_) a)))) ; ignore argument d

kar

(kar (cons 2 3))


(claim kdr
       (→ (Pair Nat Nat) Nat))

(define kdr
  (λ (pn)
    ((elim-Pair Nat Nat Nat) ; specialized on Nats
               pn
               (λ (a_ d) d)))) ; ignore argument a

(kdr (cons 2 3))


;; Frame 4.50


;; -+-+-+-+-
;;  t w i n
;; -+-+-+-+-


(claim twin
       (Π ((Y U))
          (→ Y (Pair Y Y))))

(define twin
  (λ (Y)
    (λ (x)
      (cons x x))))

((twin Atom) 'pew)


;;   ___ _              _             ___
;;  / __| |_  __ _ _ __| |_ ___ _ _  | __|
;; | (__| ' \/ _` | '_ \  _/ -_) '_| |__ \
;;  \___|_||_\__,_| .__/\__\___|_|   |___/
;;                |_|


;; Frame 5.31


(claim toppings (List Atom))

(define toppings
  (:: 'potato (:: 'butter nil)))

(claim condiments (List Atom))

(define condiments
  (:: 'chives
      (:: 'mayonnaise nil)))


;; -+-+-+-+-+-+-
;;  l e n g t h
;; -+-+-+-+-+-+-


;; reminder of rec-Nat:


;; letting rN == rec-Nat, s == some-stepper, a1 == add1
;; claim s (→ Nat Nat Nat)
;; (rN     0    b s) ~~> b
;; (rN (a1 n-1) b s) ~~> (s n-1 (rN n-1 b s))


;; pseudocode for rec-List:
;; claim s (-> E (List E) X X)            stepper
;; claim b X                              base
;; claim t (List E)                       target


;; letting rL = rec-List, s == some-stepper, :: for
;; destructuring like add1 (the "1" in add1 is
;; analogous to the additional E argument in the
;; stepper, s [Frame 5.27]; the book does not state
;; this, but it's obvious in retrospect!).
;; (rL    nil    b s) ~~> b
;; (rl (:: e es) b s) ~~> (s e es (rL es b s))


(claim step-length
       (Π ((E U))
          (→ E
             (List E)
             Nat
             Nat)))

(define step-length
  (λ (E)
    (λ (e es length-es)
      (add1 length-es))))


(claim length
       (Π ((E U))
          (→ (List E)
              Nat)))

(define length
  (λ (E)
    (λ (es)
      (rec-List es 0 (step-length E)))))


;; Frame 5.42


(claim length-Atom
       (→ (List Atom) Nat))

(define length-Atom
  (length Atom))


;; Frame 5.45


;; -+-+-+-+-+-+-
;;  a p p e n d
;; -+-+-+-+-+-+-


;; step-append is called post-destructuring into
;; (:: e es) and post-elimination of ::, just as with
;; rec-Nat.


(claim step-append
       (Π ((E U))
          (→ E
             (List E)
             (List E)
             (List E))))

(define step-append
  (λ (E)
    (λ (e es append-es)
      (:: e append-es))))


(claim append
       (Π ((E U))
          (→ (List E)
             (List E)
             (List E))))

(define append
  (λ (E)
    (λ (start end)
      (rec-List start end (step-append E)))))


((append Nat) nil nil)
(append Nat nil nil) ; Everything's curried.


(claim append-Nat
       (→ (List Nat)
          (List Nat)
          (List Nat)))

(define append-Nat
  (append Nat))


(append-Nat (:: 1 nil) nil)
(append-Nat nil (:: 2 nil))
(append-Nat (:: 1 nil) (:: 2 nil))


;; -+-+-+-+-+-+-+-
;;  r e v e r s e
;; -+-+-+-+-+-+-+-


(claim snoc
       (Π ((E U))
          (→ (List E) ; start
             E        ; element e
             (List E))))

(define snoc
  (λ (E)
    (λ (start e)
      (append E start (:: e nil)))))


;; The compiler detects, by type analysis, that
;; consing nil onto nil is illegal: it does not
;; produce a List!


;; illegal! compile error! (snoc Nat nil nil)
(snoc Nat nil 1)
(snoc Nat (:: 1 nil) 2)


(claim step-reverse
       (Π ((E U))
          (→ E
             (List E)
             (List E)
             (List E))))

;; step-reverse is called post-destructuring into
;; (:: e es) and post-elimination of ::, just as
;; with rec-Nat. So it gets two arguments, e, es,
;; as well as the recursive "almost," reversed.

(define step-reverse
  (λ (E)
    (λ (e es reversed)
      (snoc E reversed e))))


(claim reverse
       (Π ((E U))
          (→ (List E)
             (List E))))


;; I first wrote the "nil" below without peeking at
;; the answer. But they snuck one in on me, too
;; clever by half! "nil" must be explicitly typed,
;; here.


(define reverse
  (λ (E)
    (λ (es)
      (rec-List es
                (the (List E) nil)
                ;; See sneaky footnote page 125!
                (step-reverse E)))))

(reverse Nat nil)
(reverse Nat (:: 1 nil))
(reverse Nat (:: 2 (:: 1 nil)))


;;   ___ _              _              __
;;  / __| |_  __ _ _ __| |_ ___ _ _   / /
;; | (__| ' \/ _` | '_ \  _/ -_) '_| / _ \
;;  \___|_||_\__,_| .__/\__\___|_|   \___/
;;                |_|


;; two type expressions:


(Vec Atom zero)
(Vec Atom (add1 zero))


;; Vec is like a list that carries its length along
;; with it. A Vec of length 3 is of a different type
;; than a Vec of length 2. We'll have to
;; occasionally pass Nats around to remind certain
;; functions of the Nat part of a Vec type.


;; Here is an instance expression (The Little Typer
;; through chapter 6 does not use the word
;; "instance" in this way, but I use it to mean a
;; value that is not, itself, a type):


(the (Vec Atom zero) vecnil)


;; Frame 6.21


;; head and tail are built-in, but they need
;; type-hints:


(head (the (Vec Atom 1) (vec:: 'a vecnil)))


;; (head (vec:: 'a vecnil))
;; because
; Can't determine a type
;   Source locations:
;   playground.pie:71:6


(tail (the (Vec Atom 1) (vec:: 'a vecnil)))


(claim first-of-one
       (Π ((E U))
          (→ (Vec E 1) E)))

(define first-of-one
  (λ (E)
    (λ (es)
      (head es))))

(first-of-one Atom (vec:: 'shiitake vecnil))


;; Lots of expressions need type hints:


;; See https://stackoverflow.com/questions/75516108/vec-in-the-little-typer/75516109#75516109

(the (Vec Atom 1) (vec:: 'shiitake vecnil))
(the (Vec Atom 1) (vec:: (the Atom 'shiitake) vecnil))
(the (Vec Atom 1) (vec:: (the Atom 'shiitake)
                         (the (Vec Atom zero) vecnil)))
(the (Vec Atom 1) (vec:: 'shiitake
                         (the (Vec Atom zero) vecnil)))


;; -+-+-+-+-+-
;;  f i r s t
;; -+-+-+-+-+-


;; Frames 6.34 through 6.37


;;   __       __       ___ __
;;  / /____  / /____ _/ (_) /___ __
;; / __/ _ \/ __/ _ `/ / / __/ // /
;; \__/\___/\__/\_,_/_/_/\__/\_, /
;;                          /___/


;; This version of `first` requires a Nat argument,
;; ℓ-1, that is one fewer than the length of the
;; Vec. The argument must be one fewer than the
;; length so that `first` be a total function; so
;; that neither its input nor its output may ever be
;; vecnil, that is, the sole (Vec E 0). `First`
;; guarantees totality by destructuring ℓ-1 into
;; (add1 ℓ-1), which may never be zero, then
;; eliminating add1 to yield ℓ-1, which can be zero.


;; The requirement that all functions be total gives
;; the type system great power to reject values that
;; might diverge, i.e., be non-terminating or empty.


;; First must be total, so its base type must be
;; some Vec with at least one element. The _type_
;; (Vec E (add1 ℓ-1)) tells the whole story!


;; Note from the shorthand on page 138 (fifth
;; printing), one might just as well write


(claim first
       (Π ((E U)
           (ℓ-1 Nat)
           (es (Vec E (add1 ℓ-1))))
          E))

(define first
  (λ (E_ ℓ_ es)
    (head es)))


;; As what I originally wrote (without peeking):


;; (claim first
;;        (Π ((E U)
;;            (ℓ-1 Nat))
;;           (→ (Vec E (add1 ℓ-1))
;;              E)))

;; (define first
;;   (λ (E ℓ-1)
;;     (λ (es)
;;       (head es))))


(first Atom 2 (vec:: 'a (vec:: 'b (vec:: 'c vecnil))))
(first Atom 0 (vec:: 'a vecnil))


;; The book captures the lesson about totality in
;; the slogan "Use a More Specific Type ... to weed
;; out unwanted arguments" on page 137.


;; The rest of Chapter 6 seems to me just to
;; enshrine standard facts about the form of lambda
;; calculus at the type level, the form that uses
;; GREEK CAPITAL LETTER PI, Π.


;;   ___ _              _             ____
;;  / __| |_  __ _ _ __| |_ ___ _ _  |__  |
;; | (__| ' \/ _` | '_ \  _/ -_) '_|   / /
;;  \___|_||_\__,_| .__/\__\___|_|    /_/
;;                |_|


;; (define peas
;;   (λ (how-many-peas)
;;     (rec-Nat how-many-peas           ; target
;;           ;  ------v------
;;           ;    ____^_____
;;           ; == (add1 ℓ-1)
;;              vecnil                  ; base: type?
;;              (λ (ℓ-1_ peas_ℓ-1)      ; step: uh-oh
;;                (vec:: 'pea peas_ℓ-1)))))  ; type?


;; `peas` does not have a consistent type. rec-Nat
;; requires the type of `base` to be the same as
;; that of `peas_ℓ-1`. But, the type of base is
;;
;;   (Vec Atom 0),
;;
;; and the type of peas_ℓ-1 is
;;
;;   (Vec Atom ℓ-1)
;;
;; and ℓ-1 could be anything >= 0.


;; Any ___motive___ for types that depend on Nat has
;; type (→ Nat U).


;; "The motive explains _why_ the target is to be
;; eliminated." The motive, when applied to a Nat,
;; returns a type. Every type but U itself is a U.


;; I would say "how is the target destructured?"
;; because I like to distinguish destructuring and
;; elimination. Why? because it helps me to name my
;; variables. If I point out that n is destructured
;; into (add1 n-1), then it's clear that the result
;; of elimination, n-1, can be zero whilst n can't
;; and they both remain Nats.


;; Here is a shorthand synopsis for ind-Nat, which
;; does forward-rewriting by adding 1 to the input
;; step.


;; Letting iN be ind-Nat and a1 be add1:
;; claim mot (→ Nat U)
;; claim b   (mot zero)                   base
;; claim s   (Π ((n-1 Nat))               step
;;              (→ (mot    n-1)            forward ...
;;                 (mot (a1 n-1))))       rewriting
;;
;; claim iN ... target mot base step ... type is WIP
;;
;; (iN      0     m b s) ~~> b == (m 0)
;; (iN (add1 ℓ-1) m b s) ~~>
;;   (s ℓ-1 (iN ℓ-1 m b s)) == (m (add1 ℓ-1))


;; -----------------------------------------------
(claim mot-peas
       (→ Nat U))

(define mot-peas
  (λ (k) (Vec Atom k)))


;; -----------------------------------------------
(claim base-peas
       (Vec Atom 0))

(define base-peas
  vecnil)


;; -----------------------------------------------
(claim step-peas
       (Π ((ℓ-1 Nat))
          (→ (mot-peas ℓ-1)
             (mot-peas (add1 ℓ-1)))))

(define step-peas
  (λ (ℓ-1)
    (λ (peas_ℓ-1)
      (vec:: 'pea peas_ℓ-1))))


;; -----------------------------------------------
(claim peas
       (Π ((ℓ Nat))
          (Vec Atom ℓ)))

(define peas
  (λ (ℓ)
    (ind-Nat ℓ
             mot-peas
             base-peas
             step-peas)))


;; M-C-x on these after loading the file via C-c C-c.


(peas 0)
(peas 1)
(peas 3)


;; I made up the following exercise for myself.


;; Check type-fu by defining a function that's the
;; same as ind-Nat.


(claim iN
       (Π ((t   Nat)                    ; target
           (m   (→ Nat U))              ; motive
           (b   (m 0))                  ; base
           (s   (Π ((n-1 Nat))          ; step
                   (→ (m n-1)
                      (m (add1 n-1))))))
          (m t)))

(define iN
  (λ (t m b s)
    (ind-Nat
     t
     m
     b
     s)))

;; unit tests

(claim peas-ex
       (Π ((ℓ Nat))
          (Vec Atom ℓ)))

(define peas-ex
  (λ (ℓ)
    (iN ℓ
        mot-peas
        base-peas
        step-peas)))

(peas-ex 0)
(peas-ex 1)
(peas-ex 2)


;; The [official documentation for pie](https://docs.racket-lang.org/pie/#%28def._%28%28lib._pie%2Fmain..rkt%29._ind-.Nat%29%29)

;; (ind-Nat target motive base step) → (motive target)
;; target : Nat
;; motive : (-> Nat U)
;; base   : (motive zero)
;; step	 	:	(Π ((n Nat))
;;            (-> (motive n)
;;            (motive (add1 n))))


;; I got some help on this homework problem.
;; See https://racket.discourse.group/t/the-type-of-ind-nat-in-the-pie-language/1733


;; Frame 7.27


;; rec-Nat can act like ind-Nat when ind-Nat doesn't
;; use its motive, because the types don't change.


(claim also-rec-Nat
       (Π ((E U))
          (→ Nat                        ; target
             E                          ; base
             (→ Nat E E)                ; step
             E)))                       ; result

(define also-rec-Nat
  (λ (E)
    (λ (t b s)
      (ind-Nat
       t                                ; target
       (λ (k) E)                        ; motive_
       b                                ; base
       s))))                            ; step


;; -+-+-+-+-
;;  l a s t
;; -+-+-+-+-


;; -----------------------------------------------
;;
;; Frame 7.38, pg. 152 (fifth printing)
;;


;; Motives are functions that return types. "The
;; motive applied to [E and] zero should be the type
;; of the base." The type of the base of `last` is
;;
;;     (→ (Vec E (add1 zero))
;;        E)
;;
;; that is, a function of a singleton Vec that
;; returns the sole element of that Vec.


(claim mot-last
       ;; extra type argument at the front:
       (→ U Nat U))

(define mot-last
  (λ (E k-1)
    ;; Return a function from a singleton vec to an
    ;; element:
    (→ (Vec E (add1 k-1))
       E)))


(mot-last Atom zero)


(Vec U zero)                            ; type
(the (Vec U zero) vecnil)               ; instance


;; -----------------------------------------------
(claim base-last
       (Π ((E U))
          ;; The result is the type of a function
          ;; that coughs up the sole element of a
          ;; singleton Vec.
          (→ (Vec E (add1 zero))
             E)))

(define base-last
  (λ (E)
    (λ (singleton-vec)
      (head singleton-vec))))


;; -----------------------------------------------
(claim step-last
       (Π ((E U)
           (ℓ-1 Nat))
          ;; The result is the type of a function
          ;; that converts a motive of E and ℓ-1 to
          ;; a motive of E and ℓ == (add1 ℓ-1).
          (→ (mot-last E       ℓ-1 )
             (mot-last E (add1 ℓ-1)))))

;; Recall that these motives, applied to E and a
;; Nat, are functions from Vecs to elements.

(define step-last
  (λ (E ℓ-1)
    (λ (mot-of-E-and-ℓ-1) ;; convert this bad boy ...
      ;; into a new function of a Vec, es, which
      ;; applies the motive to the tail of the
      ;; Vec:
      (λ (es)
        (mot-of-E-and-ℓ-1 (tail es))))))


;; -----------------------------------------------
(claim last
       (Π ((E   U  )
           (ℓ-1 Nat))
          ;; The result is the type of a function
          ;; from a vector of at least one element
          ;; to an element:
          (→ (Vec E (add1 ℓ-1))
             E)))

;; We can cons-up `last` almost blindly:

(define last
  (λ (E ℓ-1)
    (ind-Nat ℓ-1
             (mot-last E)
             (base-last E)
             (step-last E))))

;; and unit-test it:

(last Atom 1 (vec:: 'a (vec:: 'b vecnil)))
(last Atom 0 (vec:: 'b vecnil))


;; Due to totality, we can't even write, let alone
;; compile, an expression that gets the last element
;; of an empty Vec. We can try


;; (last Atom 0 vecnil)


;; but we get
;  vecnil requires that the length be zero, not
;   1


;; -+-+-+-+-+-+-+-+-+-
;;  d r o p - l a s t
;; -+-+-+-+-+-+-+-+-+-


;; -----------------------------------------------
;;
;; Frame 7.64, pg. 160 (fifth printing)
;;


;; Motives are functions that return types. "The
;; motive applied to [E and] zero should be the type
;; of the base." The type of the base of `drop-last`
;; is the type of a function that converts a
;; singleton vector into an empty vector
;;
;;     (→ (Vec E (add1 zero))
;;        (Vec E     zero   ))


(claim mot-drop-last
       ;; extra type argument at the front:
       (→ U Nat U))

(define mot-drop-last
  (λ (E ℓ-1)
    (→ (Vec E (add1 ℓ-1 ))
       (Vec E       ℓ-1 ))))

;; unit tests:

(mot-drop-last Atom zero)  ;; (the U (→ v1 v0))
(mot-drop-last Atom 1)     ;; (the U (→ v2 v1))


;; -----------------------------------------------
;;
;; Frame 7.61
;;


;; The base is a function of a singleton Vec that
;; returns an empty Vec:


(claim base-drop-last
       (Π ((E U))
          (→ (Vec E (add1 zero))
             (Vec E       zero ))))

(define base-drop-last
  (λ (E)
    (λ (es_)
      ;; Might be overkill to spell out the type.
      ;; Might write just vecnil. Maybe pie can
      ;; reckon the type of vecnil here.
      (the (Vec E zero) vecnil))))


;; -----------------------------------------------
;;
;; Frames 7.66-67
;;


;; The type of step-drop-last is the type of a
;; function that converts a motive of E and ℓ-1 to a
;; motive of E and ℓ == (add1 ℓ-1). Except for
;; names, the claimed type of `step-drop-last` is
;; the same as the type for `step-last`, but the
;; implementation differs.


(claim step-drop-last
       (Π ((E   U  )
           (ℓ-1 Nat))
          (→ (mot-drop-last E       ℓ-1 )
             (mot-drop-last E (add1 ℓ-1)))))

(define step-drop-last
  (λ (E ℓ-1)
    ;; From a function a longer vec, return a
    ;; function from a shorter vec:
    (λ (mot-of-E-and-ℓ-1)
      (λ (es)
        (vec:: (head es)
               (mot-of-E-and-ℓ-1 (tail es)))))))

;; We can blindly write the final function:

(claim drop-last
       (Π ((E   U  )
           (ℓ-1 Nat))
          ;; The result is the type of a function
          ;; from a vector of at least one element
          ;; to a vector of one fewer elements:
          (→ (Vec E (add1 ℓ-1))
             (Vec E     ℓ-1   ))))

(define drop-last
  (λ (E ℓ-1)
    (ind-Nat ℓ-1
             (mot-drop-last E)
             (base-drop-last E)
             (step-drop-last E))))

;; unit-tests (M-C-x to see results in the REPL):

(drop-last Atom 1 (vec:: 'a (vec:: 'b vecnil)))
(drop-last Atom 0 (vec:: 'b vecnil))


;; Again, due to totality, we can't write or compile
;; an application of drop-last to an empty vector


;; (drop-last Atom 42 vecnil)
;  vecnil requires that the length be zero, not
;   43


;;  ___     _
;; |_ _|_ _| |_ ___ _ _ _ __  ___ _________
;;  | || ' \  _/ -_) '_| '  \/ -_)_ /_ / _ \
;; |___|_||_\__\___|_| |_|_|_\___/__/__\___/


;; Pages 165-168 (fifth printing) are not in any
;; chapter. We know they're not in Chapter 7 because
;; the frame numbers start at 1, and the last frame
;; in Chapter 7 is 73. Plus there is a nice picture
;; on page 164 called "one piece at a time."


;; The frames on these pages are notes on
;; interactive syntax and display format.


;; Because ["the racket REPL is
;; hopeless,"](https://github.com/racket/racket/wiki/The-toplevel-is-hopeless)
;; we can't directly do in Emacs most of the things
;; recommended in the intermezzo. I also verified
;; that they don't work in DrRacket. We can do a
;; little, though, and the results are instructive.


;; I'm commenting them out because the REPL resets
;; the cursor to the output of the TODO lines,
;; forcing me to change buffers and reset the
;; cursor to the end. That's undesirable because
;; I reload this buffer (C-c C-c) frequently.


;; (claim peas-i
;;        (Pi ((n Nat))
;;            (Vec Atom n)))

;; (define peas-i
;;   (λ (n)
;;     (ind-Nat n
;;              (λ (k) (Vec Atom k))       ; motive
;;              vecnil                     ; base
;;              (λ (n-1 ps-1)              ; step
;;                (vec:: TODO TODO)))))


;;   ___ _              _             ___
;;  / __| |_  __ _ _ __| |_ ___ _ _  ( _ )
;; | (__| ' \/ _` | '_ \  _/ -_) '_| / _ \
;;  \___|_||_\__,_| .__/\__\___|_|   \___/
;;                |_|


;; Normal form of (+ 1) -- partial application of +
;; to 1 == (add1 zero). Recall:


;; (define +
;;   (λ (n j) ;; Don't use the name n-1 here.
;;     ;;        target base  step  ; the pattern
;;     ;;       |------|----|-------|
;;     (iter-Nat    n     j   step-+)))


;; (+ 1)
;; (+ (add1 zero))                        destructuring
;; (λ (j)
;;   (iter-Nat (add1 zero) j step-+))     subst. def
;; (λ (j)
;;   (step-+
;;     (iter-Nat   zero                   elimination
;;                 j step-+)))
;; (λ (j)
;;   (add1                                subst. def
;;     (iter-Nat   zero j step-+)))
;; (λ (j) (add1 j))                       subst. def


(claim incr (→ Nat Nat))

(define incr
  (λ (n)
    (iter-Nat n                         ; target
              1                         ; base
              (+ 1))))                  ; step


;; Note that pie doesn't let us write add1 in place
;; of (+ 1), above. Must be that add1 isn't a
;; function?


;;add1
; ...: add1: expected valid Pie name
;   at: add1
;   in: add1


;; But


;; playground.pie> (+ 1)
;; (the (→ Nat
;;         Nat)
;;      (λ (j)
;;        (add1 j)))


;; The book makes the point that the normal forms
;; of the expressions (+ 1) and incr are not the
;; same. Save some hand calculation by letting
;; the REPL compute the normal forms:


;; playground.pie> (+ 1)
;; (the (→ Nat
;;         Nat)
;;      (λ (j)
;;        (add1 j)))
;;
;; playground.pie> incr
;; (the (→ Nat
;;         Nat)
;;      (λ (n)
;;        (iter-Nat n
;;                  (the Nat 1)
;;                  (λ (j)
;;                    (add1 j)))))


;; "Even though they are not the same, the fact that
;; they always find the same answer can be written
;; as a type.
;;    "Sameness is indeed a judgment. But, with a
;; new type constructor, types can express a new
;; idea called _equality_."


;; -+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f   =
;; -+-+-+-+-+-+-+-+-+-+-+-+-


;; "An expression
;;
;;     (= X _from_ _to_)
;;
;; is a type if X is a type, _from_ is an X, and
;; _to_ is an X."


;; FROM and TO need not be types, but they must be
;; of type X. Therefore, an (= ...) is a dependent
;; type because it depends on things that might not,
;; themselves, be types.


(= Nat (+ 6 7) 13)
;; (the U
;;      (= Nat 13 13))


;; Frames 8.15-18. There is a lot going on here:
;; Bertrand Russell and lots more.


;; "Types can be read as _statements_."


;; The one above says "6 + 7 equals 13," a
;; statement. "6+7 is the same Nat as 7" is a
;; _judgment_, one of form 2.


;; The Four Forms of Judgment:
;;
;; 1. ____ is a ____.
;;
;; 2. ____ is the same ____ as ____.
;;
;; 3. ____ is a type.
;;
;; 4. ____ and ____ are the same type.


;; Judgments are for humans; statements are for
;; computers; more precisely, for computer
;; theorem-provers.


;; Frame 8.21


;; "'6+7 equals 13' is a type" is a judgment of
;; form 1.


;; Π-expressions are universal quantifications, i.e,
;; "for-every," ∀, statements.


;; Frame 8.23


(Π ((n Nat))
   (= Nat (+ 1 n) (add1 n)))
;; (the U
;;      (Π ((n Nat))
;;         (= Nat
;;            (add1 n)
;;            (add1 n))))


;; I made up the following exercise.


;; Oh, LOOK! The normal forms converged! Is that
;; fact significant? No, because the normal form
;; of (+ 1) is add1. How about this:


(Π ((n Nat))
   (= Nat (+ 1 n) (incr n)))
;; (the U
;;      (Π ((n Nat))
;;         (= Nat
;;            (add1 n)
;;            (iter-Nat n
;;                      (the Nat 1)
;;                      (λ (j)
;;                        (add1 j))))))


;; ... much more meaty!
