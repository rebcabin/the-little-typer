#lang pie  ;; Racket support this language as a
           ;; package.


;;   ___ _                _   __       ___
;;  / __| |_  _ __ ___   / | / _|___  |_  )
;; | (__| ' \| '_ (_-<_  | | > _|_ _|  / /
;;  \___|_||_| .__/__(_) |_| \_____|  /___|
;;           |_|


;; In Emacs racket-mode, C-c C-c sends the whole
;; file to the racket interpreter. C-M-x sends the
;; s-exp that surrounds the cursor, just as with
;; CIDER in Clojure-mode.


;; Alternatively, if you don't want to set up Emacs
;; for racket, load this file into DrRacket and play
;; around. DrRacket comes for free with [the racket
;; distribution](https://download.racket-lang.org/).
;; Install the distribution, type `raco kg install
;; pie` at the terminal, launch `DrRacket` and party
;; on. DrRacket is a fine IDE if you can stand
;; imperfect Emacs key-binding emulation (I can't;
;; too many decades of muscle memory!)


;; Mostly, I leave two blank lines between things. I
;; leave one blank line between a `claim` and its
;; matching `define`. Writing these pairs _feels
;; like_ writing Haskell. I also sometimes leave a
;; single blank line between a definition and its
;; unit tests. I'm not religious about any of that.


'spinach


(the (Pair Atom Atom)
  (cons 'spinach 'cauliflower))


(the Atom (the Atom 'pie))


;; -+-+-+-+-+-+-+-+-+-
;;  w h i c h - N a t
;; -+-+-+-+-+-+-+-+-+-


;; TODO: Understand why this type signature fails.


(claim wN
       (Π ((E      U        )
           (target Nat      )
           (base   E        )
           (step   (→ Nat E)))
          (→ U U U ;target base step
             E)))


;; which-Nat has type
;; (Π ((E      U)
;;     (target N)
;;     (base   E)
;;     (step   (→ N E)))
;;   (→ target base step E))
;;
;; or, less noisily
;;
;; (Π ((E U))
;;   (→ N E (→ N E) E))


;; The base and the output of step must have the same
;; type (E U). E can be anything -- Atom or Nat, for
;; instance, but it must be the same on both branches
;; of which-Nat.


;; Here is pseudocode for which-Nat:


;; (which-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then which-Nat = (step n-1)


;; A good name for the argument (parameter?) of step
;; is n-1 because step is called with n-1 when
;; target == n == (add1 n-1).


;; A parameter is a name for an argument. What is
;; the name of a parameter (your answer)?


;; SPOILER: Parameters inhabit a space of symbolic
;; calculation inside the compiler or its run-time,
;; representative functions like add1. Names of
;; parameters only appear in the implementations of
;; the compiler or its run-time representative
;; functions, where they may stand for arbitrary
;; parameters. At the user's level. parameters are
;; names for arguments, where they may stand for
;; arbitrary argument values. Recall that values are
;; expressions with constructors up top (in first
;; positions in parenthesized expressions).


(which-Nat zero 'naught (λ (n-1) 'more))
(which-Nat 4    'naught (λ (n-1) 'three))


;; I made up the following to show how rec-Nat can
;; mimic the behavior of which-Nat, i.e., by the
;; step's ignoring both its arguments:


(rec-Nat zero 'rec-naught (λ (n-1 r) 'rec-more))
(rec-Nat 4    'rec-naught (λ (n-1 r) 'rec-three))


;; Notice that rec-Nat "destructures" its argument
;; into (add1 n-1) and then "eliminates" add1 before
;; handing n-1 to the step function, (λ (n-1 r)
;; 'some-atom). We write more about destructuring
;; and elimination below.


;; The book writes _ignored arguments_ in dim font.
;; I think one need not bother much about that. But
;; one might sometimes write _ or foo_ with a _
;; suffix for ignored arguments. Lots of programming
;; languages follow that convention, sometimes
;; allowing multiple instances of _ without
;; collision.


;; Later, we'll see that by step's ignoring one of
;; its arguments, namely r, the recursive
;; computation, rec-Nat simulates iter-Nat.


;;   ___ _              _             ____
;;  / __| |_  __ _ _ __| |_ ___ _ _  |__ /
;; | (__| ' \/ _` | '_ \  _/ -_) '_|  |_ \
;;  \___|_||_\__,_| .__/\__\___|_|   |___/
;;                |_|


;; Frame 3.23


;; All these functions follow a pattern, with
;; parameters target, base, and step.


;;        target base      step
;;       |------|----|----------------|
(iter-Nat    5     3  (λ (k) (add1 k)))


;; Discovery about pie (the language of this file).
;; Can't go to point-free form, i.e., cannot use
;; add1 for (λ (k) (add1 k)).
;;
;; (iter-Nat 5 3 add1) ;
;; .../the-little-typer/playground.pie:17:14:
;; add1: expected valid Pie name
;   at: add1
;   in: add1


;; pseudocode for iter-Nat


;; (iter-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then iter-Nat ==
;; (step
;;    (iter-Nat n-1 base step))


;; iter-Nat has type
;;
;; (Π ((E U))
;;   (→ N E (→ N E) E))
;;
;; same as the type of which-Nat. The difference
;; between the two is that iter-Nat calls iter-Nat
;; for the argument of step. User-defined code must
;; not recurse, but this system-defined routine can.


;; (+ 2 3) ;; ; Unknown variable +


(claim step-+
       (→ Nat Nat))

(define step-+
  (λ (n-1) (add1 n-1)))


(claim + (→ Nat Nat Nat))

(define +
  (λ (n j) ;; Don't use the name n-1 here.
    ;;        target base  step  ; the pattern
    ;;       |------|----|-------|
    (iter-Nat    n     j   step-+)))


;; Frame 3.28, sort-of


;; reminder of the pseudocode of which-Nat:


;; (which-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then which-Nat = (step n-1)


;; -+-+-+-+-+-+-+-+-+-+-+-
;;  e l i m i n a t i o n
;; -+-+-+-+-+-+-+-+-+-+-+-


;; The process of replacing (add1 n-1) with n-1 is
;; called "elimination" because it strips off --
;; eliminates -- the value constructor add1.
;; Selection (which-Nat), iteration (iter-Nat), and
;; recursion (rec-Nat) occur in a backwards kind of
;; way, by eliminating toward zero. One says
;; "backwards" because one's prior experience with
;; recursion and iteration probably has one starting
;; with some big Nat and _subtracting_ 1 from it by
;; an arithmetic process before recursing. Here, in
;; The Little Typer, we instead destructure larger
;; numbers n into smaller ones (add1 n-1) by writing
;; out the _addition_ that "must have taken place."
;; The effect is the same, but preserves type
;; information here. This kind of reckoning is
;; probably best in any implementation of a type
;; system.


;; Sequential deconstruction and elimination *build
;; up* an expression of smaller Nats. The expression
;; that is eventually evaluated to the unique normal
;; form -- the "most direct" form.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  d e s t r u c t u r i n g
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-


;; The process of noticing that n == (add1 n-1) is
;; "destructuring," a term not in The Little Typer.
;; I borrowed it from Clojure. One might think it
;; should be called "structuring" because it
;; substitutes a value like (add1 n-1), with a
;; constructor up top, for an expression like n.
;; However, I always pair destructuring with a
;; following elimination, so it's more a partner of
;; elimination than it is a stand-alone operation.
;; Also, I wanted to mimic the meaning from Clojure,
;; which uses destructuring to unpack argument
;; expressions into value forms, typically with
;; Clojure keywords taking the role of Pie's
;; constructors.


;; Destructuring, in our example, defines the
;; argument n-1 by setting up the value (add1 n-1)
;; [constructor add1 up top, as if a Clojure
;; keyword] for later elimination to n-1.


;; (iter-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;;                               |-------------|
;;                                destructuring
;; then iter-Nat ==        ______/
;;                        /
;;             elimination
;; (step       |---------|
;;    (iter-Nat    n-1    base step))


;; Here is a "same-chart" for "(+ 2 3)." I assume we
;; understand "subst.", i.e., substitution, without
;; further explanation:


(+ 2 3) ; 1. ...                          how? why?
;; 2.     (iter-Nat     2    3 step-+)    subst. def
;; 3.     (iter-Nat (add1 1) 3 step-+)    destructuring
;; 4. (step-+            /                elimination
;;        (iter-Nat     1    3 step-+))
;; 5. (step-+       ____^___
;;        (iter-Nat (add1 0) 3 step-+))   destructuring
;; 6. (step-+            /                elimination
;;      (step-+         |
;;        (iter-Nat     0    3 step-+)))
;;        -------------------v--------
;; 7. (step-+                |            subst. base
;;      (step-+              3))
;; ~~~> 5                                 evaluation


;; Here is something I made up to show that rec-Nat
;; is at least as strong as iter-Nat.


;; (rec-Nat target base step) == base if
;; target == 0 else if target == (add1 n-1)
;; then rec-Nat ==
;; (step n-1                              nota bene
;;    (rec-Nat n-1 base step))            elimination

(claim sr+
       (→ Nat Nat Nat))

(define sr+
  (λ (n-1 r) (add1 n-1))) ;               ignore r


(rec-Nat 2 3 sr+) ; 1. ...
;; 2.     (rec-Nat     2    3 sr+)        subst. def
;;                 ____^___
;; 3.     (rec-Nat (add1 1) 3 sr+)        destructuring
;; 4. (sr+ 1            /                 elimination
;;        (rec-Nat     1    3 sr+))
;; 5. (sr+ 1       ____^___               destructuring
;;        (rec-Nat (add1 0) 3 sr+))
;; 6. (sr+ 0            /                 elimination
;;      (sr+ 0         |
;;        (rec-Nat     0    3 sr+)))
;;        ------------------v-----        subst. base
;; 7. (sr+ 0                |
;;      (sr+ 0              3))
;; ~~~> 5                                 evaluation


;; -+-+-+-+-+-
;;  g a u s s
;; -+-+-+-+-+-


;; Here is an example rec-Nat stepper that uses both
;; arguments that rec-Nat gives it:


(claim step-gauss
       (→ Nat Nat
          Nat))

(define step-gauss
  (λ (n-1 rg)
    (+ (add1 n-1) rg)))


(claim gauss
       (→ Nat Nat))

(define gauss
  (λ (n) ; Don't name this argument n-1
    (rec-Nat n ; "target": if zero, return ...
             0 ; "base": else, if it's (add1 n-1)
             ;; return
             ;; (step-gauss
             ;;   (rec-Nat n-1
             ;;            base
             ;;            step-gauss)
             step-gauss)))


;; Less noisy pseudocode:


;; letting rN == rec-Nat, s == some-stepper, a1 == add1
;; claim s (→ Nat Nat Nat)
;; (rN     0    b s) ~~> b
;; (rN (a1 n-1) b s) ~~> (s n-1 (rN n-1 b s))


(gauss 3) ; 1. ...
;; 2.       (rN    3   0 sg)              subst. def
;;              ___^__
;; 3.       (rN (a1 2) 0 sg)              destructuring
;; 4. (sg 2        /                      elimination
;;          (rN    2   0 sg))
;; 5. (sg 2     ___^__
;;          (rN (a1 1) 0 sg))             destructuring
;; 6. (sg 2        /                      elimination
;;      (sg 1      |
;;          (rN    1   0 sg)))
;; 6. (sg 2        |
;;      (sg 1   ___^__
;;          (rN (a1 0) 0 sg)))            destructuring
;; 7. (sg 2        /                      elimination
;;      (sg 1      |
;;        (sg 0    |
;;          (rN    0   0 sg))))
;; 8. (sg 2 -------v--------
;;      (sg 1      |
;;        (sg 0    0)))                   subst. base
;; 9. (sg 2 (sg 1 (+ (add1 0) 0)))        apply +,
;; A. (sg 2 (sg 1 1))                     including
;; B. (sg 2 (+ (add1 1) 1))               multiple
;; C. (sg 2 3)                            steps not
;; D. (+ (add1 2) 3)                      exploded here
;; E. 6


;;   ___ _              _             _ _
;;  / __| |_  __ _ _ __| |_ ___ _ _  | | |
;; | (__| ' \/ _` | '_ \  _/ -_) '_| |_  _|
;;  \___|_||_\__,_| .__/\__\___|_|     |_|
;;                |_|


;; This chapter is mostly about the miniature
;; calculus on types, a calculus effected by Π. I
;; assume this is easy, so I don't talk much, just
;; show some examples. In Emacs, type M-C-x with the
;; cursor in an example to see its value in the
;; pie/racket interpreter.


;; (claim foo (→ A D))
;; page 98:  ~" → is not up to the job "~


;; -+-+-+-+-
;;  f l i p
;; -+-+-+-+-


(claim flip
       (Π ((A U) (D U))
          (→ (Pair A D)
              (Pair D A))))

(define flip
  (λ (A D)
    (λ (p)
      (cons (cdr p) (car p)))))

(flip Nat Nat)

((flip Nat Atom) (cons 17 'apple))

((flip Nat Nat) (cons 2 3))


(claim elim-Pair
       (Π ((A U) (D U) (X U))
          (→ (Pair A D)
              (→ A D X)
              X)))

(define elim-Pair
  (λ (A D X)
    (λ (p f)
      (f (car p) (cdr p)))))

elim-Pair


;; -+-+-+-+-+-+-+-+-
;;  k a r ,   k d r
;; -+-+-+-+-+-+-+-+-


;; These kar and kdr functions are specialized for
;; Nats. kar and kdr are probably lousy names for
;; them, but go with them just to exit the chapter.
;; `elim-pair` is not specialized, so bracket the
;; function-calls appropriately.


(claim kar
       (→ (Pair Nat Nat) Nat))

(define kar
  (λ (p)
    ((elim-Pair Nat Nat Nat) ; specialized on Nats
               p
               (λ (a d_) a)))) ; ignore argument d

kar

(kar (cons 2 3))


(claim kdr
       (→ (Pair Nat Nat) Nat))

(define kdr
  (λ (pn)
    ((elim-Pair Nat Nat Nat) ; specialized on Nats
               pn
               (λ (a_ d) d)))) ; ignore argument a

(kdr (cons 2 3))


;; Frame 4.50


;; -+-+-+-+-
;;  t w i n
;; -+-+-+-+-


(claim twin
       (Π ((Y U))
          (→ Y (Pair Y Y))))

(define twin
  (λ (Y)
    (λ (x)
      (cons x x))))

((twin Atom) 'pew)


;;   ___ _              _             ___
;;  / __| |_  __ _ _ __| |_ ___ _ _  | __|
;; | (__| ' \/ _` | '_ \  _/ -_) '_| |__ \
;;  \___|_||_\__,_| .__/\__\___|_|   |___/
;;                |_|


;; Frame 5.31


(claim toppings (List Atom))

(define toppings
  (:: 'potato (:: 'butter nil)))

(claim condiments (List Atom))

(define condiments
  (:: 'chives
      (:: 'mayonnaise nil)))


;; -+-+-+-+-+-+-
;;  l e n g t h
;; -+-+-+-+-+-+-


;; reminder of rec-Nat:


;; letting rN == rec-Nat, s == some-stepper, a1 == add1
;; claim s (→ Nat Nat Nat)
;; (rN     0    b s) ~~> b
;; (rN (a1 n-1) b s) ~~> (s n-1 (rN n-1 b s))


;; pseudocode for rec-List:
;; claim s (-> E (List E) X X)            stepper
;; claim b X                              base
;; claim t (List E)                       target


;; letting rL = rec-List, s == some-stepper, :: for
;; destructuring like add1 (the "1" in add1 is
;; analogous to the additional E argument in the
;; stepper, s [Frame 5.27]; the book does not state
;; this, but it's obvious in retrospect!).
;; (rL    nil    b s) ~~> b
;; (rl (:: e es) b s) ~~> (s e es (rL es b s))


(claim step-length
       (Π ((E U))
          (→ E
             (List E)
             Nat
             Nat)))

(define step-length
  (λ (E)
    (λ (e es length-es)
      (add1 length-es))))


(claim length
       (Π ((E U))
          (→ (List E)
              Nat)))

(define length
  (λ (E)
    (λ (es)
      (rec-List es 0 (step-length E)))))


;; Frame 5.42


(claim length-Atom
       (→ (List Atom) Nat))

(define length-Atom
  (length Atom))


;; Frame 5.45


;; -+-+-+-+-+-+-
;;  a p p e n d
;; -+-+-+-+-+-+-


;; step-append is called post-destructuring into
;; (:: e es) and post-elimination of ::, just as with
;; rec-Nat.


(claim step-append
       (Π ((E U))
          (→ E
             (List E)
             (List E)
             (List E))))

(define step-append
  (λ (E)
    (λ (e es append-es)
      (:: e append-es))))


(claim append
       (Π ((E U))
          (→ (List E)
             (List E)
             (List E))))

(define append
  (λ (E)
    (λ (start end)
      (rec-List start end (step-append E)))))


((append Nat) nil nil)
(append Nat nil nil) ; Everything's curried.


(claim append-Nat
       (→ (List Nat)
          (List Nat)
          (List Nat)))

(define append-Nat
  (append Nat))


(append-Nat (:: 1 nil) nil)
(append-Nat nil (:: 2 nil))
(append-Nat (:: 1 nil) (:: 2 nil))


;; -+-+-+-+-+-+-+-
;;  r e v e r s e
;; -+-+-+-+-+-+-+-


(claim snoc
       (Π ((E U))
          (→ (List E) ; start
             E        ; element e
             (List E))))

(define snoc
  (λ (E)
    (λ (start e)
      (append E start (:: e nil)))))


;; The compiler detects, by type analysis, that
;; consing nil onto nil is illegal: it does not
;; produce a List!


;; illegal! compile error! (snoc Nat nil nil)
(snoc Nat nil 1)
(snoc Nat (:: 1 nil) 2)


(claim step-reverse
       (Π ((E U))
          (→ E
             (List E)
             (List E)
             (List E))))

;; step-reverse is called post-destructuring into
;; (:: e es) and post-elimination of ::, just as
;; with rec-Nat. So it gets two arguments, e, es,
;; as well as the recursive "almost," reversed.

(define step-reverse
  (λ (E)
    (λ (e es reversed)
      (snoc E reversed e))))


(claim reverse
       (Π ((E U))
          (→ (List E)
             (List E))))


;; I first wrote the "nil" below without peeking at
;; the answer. But they snuck one in on me, too
;; clever by half! "nil" must be explicitly typed,
;; here.


(define reverse
  (λ (E)
    (λ (es)
      (rec-List es
                (the (List E) nil)
                ;; See sneaky footnote page 125!
                (step-reverse E)))))

(reverse Nat nil)
(reverse Nat (:: 1 nil))
(reverse Nat (:: 2 (:: 1 nil)))


;;   ___ _              _              __
;;  / __| |_  __ _ _ __| |_ ___ _ _   / /
;; | (__| ' \/ _` | '_ \  _/ -_) '_| / _ \
;;  \___|_||_\__,_| .__/\__\___|_|   \___/
;;                |_|


;; two type expressions:


(Vec Atom zero)
(Vec Atom (add1 zero))


;; Vec is like a list that carries its length along
;; with it. A Vec of length 3 is of a different type
;; than a Vec of length 2. We'll have to
;; occasionally pass Nats around to remind certain
;; functions of the Nat part of a Vec type.


;; Here is an instance expression (The Little Typer
;; through chapter 6 does not use the word
;; "instance" in this way, but I use it to mean a
;; value that is not, itself, a type):


(the (Vec Atom zero) vecnil)


;; Frame 6.21


;; head and tail are built-in, but they need
;; type-hints:


(head (the (Vec Atom 1) (vec:: 'a vecnil)))


;; (head (vec:: 'a vecnil))
;; because
; Can't determine a type
;   Source locations:
;   playground.pie:71:6


(tail (the (Vec Atom 1) (vec:: 'a vecnil)))


(claim first-of-one
       (Π ((E U))
          (→ (Vec E 1) E)))

(define first-of-one
  (λ (E)
    (λ (es)
      (head es))))

(first-of-one Atom (vec:: 'shiitake vecnil))


;; Lots of expressions need type hints:


;; See https://stackoverflow.com/questions/75516108/vec-in-the-little-typer/75516109#75516109

(the (Vec Atom 1) (vec:: 'shiitake vecnil))
(the (Vec Atom 1) (vec:: (the Atom 'shiitake) vecnil))
(the (Vec Atom 1) (vec:: (the Atom 'shiitake)
                         (the (Vec Atom zero) vecnil)))
(the (Vec Atom 1) (vec:: 'shiitake
                         (the (Vec Atom zero) vecnil)))


;; -+-+-+-+-+-
;;  f i r s t
;; -+-+-+-+-+-


;; Frames 6.34 through 6.37


;;   __       __       ___ __
;;  / /____  / /____ _/ (_) /___ __
;; / __/ _ \/ __/ _ `/ / / __/ // /
;; \__/\___/\__/\_,_/_/_/\__/\_, /
;;                          /___/


;; This version of `first` requires a Nat argument,
;; ℓ-1, that is one fewer than the length of the
;; Vec. The argument must be one fewer than the
;; length so that `first` be a total function; so
;; that neither its input nor its output may ever be
;; vecnil, that is, the sole (Vec E 0). `First`
;; guarantees totality by destructuring ℓ-1 into
;; (add1 ℓ-1), which may never be zero, then
;; eliminating add1 to yield ℓ-1, which can be zero.


;; The requirement that all functions be total gives
;; the type system great power to reject values that
;; might diverge, i.e., be non-terminating or empty.


;; First must be total, so its base type must be
;; some Vec with at least one element. The _type_
;; (Vec E (add1 ℓ-1)) tells the whole story!


;; Note from the shorthand on page 138 (fifth
;; printing), one might just as well write


(claim first
       (Π ((E U)
           (ℓ-1 Nat)
           (es (Vec E (add1 ℓ-1))))
          E))

(define first
  (λ (E_ ℓ_ es)
    (head es)))


;; As what I originally wrote (without peeking):


;; (claim first
;;        (Π ((E U)
;;            (ℓ-1 Nat))
;;           (→ (Vec E (add1 ℓ-1))
;;              E)))

;; (define first
;;   (λ (E ℓ-1)
;;     (λ (es)
;;       (head es))))


(first Atom 2 (vec:: 'a (vec:: 'b (vec:: 'c vecnil))))
(first Atom 0 (vec:: 'a vecnil))


;; The book captures the lesson about totality in
;; the slogan "Use a More Specific Type ... to weed
;; out unwanted arguments" on page 137.


;; The rest of Chapter 6 seems to me just to
;; enshrine standard facts about the form of lambda
;; calculus at the type level, the form that uses
;; GREEK CAPITAL LETTER PI, Π.


;;   ___ _              _             ____
;;  / __| |_  __ _ _ __| |_ ___ _ _  |__  |
;; | (__| ' \/ _` | '_ \  _/ -_) '_|   / /
;;  \___|_||_\__,_| .__/\__\___|_|    /_/
;;                |_|


;; (define peas
;;   (λ (how-many-peas)
;;     (rec-Nat how-many-peas           ; target
;;           ;  ------v------
;;           ;    ____^_____
;;           ; == (add1 ℓ-1)
;;              vecnil                  ; base: type?
;;              (λ (ℓ-1_ peas_ℓ-1)      ; step: uh-oh
;;                (vec:: 'pea peas_ℓ-1)))))  ; type?


;; `peas` does not have a consistent type. rec-Nat
;; requires the type of `base` to be the same as
;; that of `peas_ℓ-1`. But, the type of base is
;;
;;   (Vec Atom 0),
;;
;; and the type of peas_ℓ-1 is
;;
;;   (Vec Atom ℓ-1)
;;
;; and ℓ-1 could be anything >= 0.


;; Any ___motive___ for types that depend on Nat has
;; type (→ Nat U).


;; "The motive explains _why_ the target is to be
;; eliminated." The motive, when applied to a Nat,
;; returns a type. Every type but U itself is a U.


;; I would say "how is the target destructured?"
;; because I like to distinguish destructuring and
;; elimination. Why? because it helps me to name my
;; variables. If I point out that n is destructured
;; into (add1 n-1), then it's clear that the result
;; of elimination, n-1, can be zero whilst n can't
;; and they both remain Nats.


;; Here is a shorthand synopsis for ind-Nat, which
;; does forward-rewriting by adding 1 to the input
;; step.


;; Letting iN be ind-Nat and a1 be add1:
;; claim mot (→ Nat U)
;; claim b   (mot zero)                   base
;; claim s   (Π ((n-1 Nat))               step
;;              (→ (mot    n-1)            forward ...
;;                 (mot (a1 n-1))))       rewriting
;;
;; claim iN
;; (Π ((t   Nat)                    ; target
;;     (m   (→ Nat U))              ; motive
;;     (b   (m 0))                  ; base
;;     (s   (Π ((n-1 Nat))          ; step
;;             (→ (m n-1)
;;                (m (add1 n-1))))))
;;    (m t))
;;
;; (iN      0     m b s) ~~> b == (m 0)
;; (iN (add1 ℓ-1) m b s) ~~>
;;   (s ℓ-1 (iN ℓ-1 m b s)) == (m (add1 ℓ-1))


;; -----------------------------------------------
(claim mot-peas
       (→ Nat U))

(define mot-peas
  (λ (k) (Vec Atom k)))


;; -----------------------------------------------
(claim base-peas
       (Vec Atom 0))

(define base-peas
  vecnil)


;; -----------------------------------------------
(claim step-peas
       (Π ((ℓ-1 Nat))
          (→ (mot-peas ℓ-1)
             (mot-peas (add1 ℓ-1)))))

(define step-peas
  (λ (ℓ-1)
    (λ (peas_ℓ-1)
      (vec:: 'pea peas_ℓ-1))))


;; -----------------------------------------------
(claim peas
       (Π ((ℓ Nat))
          (Vec Atom ℓ)))

(define peas
  (λ (ℓ)
    (ind-Nat ℓ
             mot-peas
             base-peas
             step-peas)))


;; M-C-x on these after loading the file via C-c C-c.


(peas 0)
(peas 1)
(peas 3)


;; I made up the following exercise for myself.


;; Check type-fu by defining a function that's the
;; same as ind-Nat.


(claim iN
       (Π ((t   Nat)                    ; target
           (m   (→ Nat U))              ; motive
           (b   (m 0))                  ; base
           (s   (Π ((n-1 Nat))          ; step
                   (→ (m n-1)
                      (m (add1 n-1))))))
          (m t)))

(define iN
  (λ (t m b s)
    (ind-Nat
     t
     m
     b
     s)))

;; unit tests

(claim peas-ex
       (Π ((ℓ Nat))
          (Vec Atom ℓ)))

(define peas-ex
  (λ (ℓ)
    (iN ℓ
        mot-peas
        base-peas
        step-peas)))

(peas-ex 0)
(peas-ex 1)
(peas-ex 2)


;; The [official documentation for pie](https://docs.racket-lang.org/pie/#%28def._%28%28lib._pie%2Fmain..rkt%29._ind-.Nat%29%29)

;; (ind-Nat target motive base step) → (motive target)
;; target : Nat
;; motive : (-> Nat U)
;; base   : (motive zero)
;; step	 	:	(Π ((n Nat))
;;            (-> (motive n)
;;            (motive (add1 n))))


;; I got some help on this homework problem.
;; See https://racket.discourse.group/t/the-type-of-ind-nat-in-the-pie-language/1733


;; Frame 7.27


;; rec-Nat can act like ind-Nat when ind-Nat doesn't
;; use its motive, because the types don't change.


(claim also-rec-Nat
       (Π ((E U))
          (→ Nat                        ; target
             E                          ; base
             (→ Nat E E)                ; step
             E)))                       ; result

(define also-rec-Nat
  (λ (E)
    (λ (t b s)
      (ind-Nat
       t                                ; target
       (λ (k) E)                        ; motive_
       b                                ; base
       s))))                            ; step


;; -+-+-+-+-
;;  l a s t
;; -+-+-+-+-


;; -----------------------------------------------
;;
;; Frame 7.38, pg. 152 (fifth printing)
;;


;; Motives are functions that return types. "The
;; motive applied to [E and] zero should be the type
;; of the base." The type of the base of `last` is
;;
;;     (→ (Vec E (add1 zero))
;;        E)
;;
;; that is, a function of a singleton Vec that
;; returns the sole element of that Vec.


(claim mot-last
       ;; extra type argument at the front:
       (→ U Nat U))

(define mot-last
  (λ (E k-1)
    ;; Return a function from a singleton vec to an
    ;; element:
    (→ (Vec E (add1 k-1))
       E)))


(mot-last Atom zero)


(Vec U zero)                            ; type
(the (Vec U zero) vecnil)               ; instance


;; -----------------------------------------------
(claim base-last
       (Π ((E U))
          ;; The result is the type of a function
          ;; that coughs up the sole element of a
          ;; singleton Vec.
          (→ (Vec E (add1 zero))
             E)))

(define base-last
  (λ (E)
    (λ (singleton-vec)
      (head singleton-vec))))


;; -----------------------------------------------
(claim step-last
       (Π ((E U)
           (ℓ-1 Nat))
          ;; The result is the type of a function
          ;; that converts a motive of E and ℓ-1 to
          ;; a motive of E and ℓ == (add1 ℓ-1).
          (→ (mot-last E       ℓ-1 )
             (mot-last E (add1 ℓ-1)))))

;; Recall that these motives, applied to E and a
;; Nat, are functions from Vecs to elements.

(define step-last
  (λ (E ℓ-1)
    (λ (mot-of-E-and-ℓ-1) ;; convert this bad boy ...
      ;; into a new function of a Vec, es, which
      ;; applies the motive to the tail of the
      ;; Vec:
      (λ (es)
        (mot-of-E-and-ℓ-1 (tail es))))))


;; -----------------------------------------------
(claim last
       (Π ((E   U  )
           (ℓ-1 Nat))
          ;; The result is the type of a function
          ;; from a vector of at least one element
          ;; to an element:
          (→ (Vec E (add1 ℓ-1))
             E)))

;; We can cons-up `last` almost blindly:

(define last
  (λ (E ℓ-1)
    (ind-Nat ℓ-1
             (mot-last E)
             (base-last E)
             (step-last E))))

;; and unit-test it:

(last Atom 1 (vec:: 'a (vec:: 'b vecnil)))
(last Atom 0 (vec:: 'b vecnil))


;; Due to totality, we can't even write, let alone
;; compile, an expression that gets the last element
;; of an empty Vec. We can try


;; (last Atom 0 vecnil)


;; but we get
;  vecnil requires that the length be zero, not
;   1


;; -+-+-+-+-+-+-+-+-+-
;;  d r o p - l a s t
;; -+-+-+-+-+-+-+-+-+-


;; -----------------------------------------------
;;
;; Frame 7.64, pg. 160 (fifth printing)
;;


;; Motives are functions that return types. "The
;; motive applied to [E and] zero should be the type
;; of the base." The type of the base of `drop-last`
;; is the type of a function that converts a
;; singleton vector into an empty vector
;;
;;     (→ (Vec E (add1 zero))
;;        (Vec E     zero   ))


(claim mot-drop-last
       ;; extra type argument at the front:
       (→ U Nat U))

(define mot-drop-last
  (λ (E ℓ-1)
    (→ (Vec E (add1 ℓ-1 ))
       (Vec E       ℓ-1 ))))

;; unit tests:

(mot-drop-last Atom zero)  ;; (the U (→ v1 v0))
(mot-drop-last Atom 1)     ;; (the U (→ v2 v1))


;; -----------------------------------------------
;;
;; Frame 7.61
;;


;; The base is a function of a singleton Vec that
;; returns an empty Vec:


(claim base-drop-last
       (Π ((E U))
          (→ (Vec E (add1 zero))
             (Vec E       zero ))))

(define base-drop-last
  (λ (E)
    (λ (es_)
      ;; Might be overkill to spell out the type.
      ;; Might write just vecnil. Maybe pie can
      ;; reckon the type of vecnil here.
      (the (Vec E zero) vecnil))))


;; -----------------------------------------------
;;
;; Frames 7.66-67
;;


;; The type of step-drop-last is the type of a
;; function that converts a motive of E and ℓ-1 to a
;; motive of E and ℓ == (add1 ℓ-1). Except for
;; names, the claimed type of `step-drop-last` is
;; the same as the type for `step-last`, but the
;; implementation differs.


(claim step-drop-last
       (Π ((E   U  )
           (ℓ-1 Nat))
          (→ (mot-drop-last E       ℓ-1 )
             (mot-drop-last E (add1 ℓ-1)))))

(define step-drop-last
  (λ (E ℓ-1)
    ;; From a function a longer vec, return a
    ;; function from a shorter vec:
    (λ (mot-of-E-and-ℓ-1)
      (λ (es)
        (vec:: (head es)
               (mot-of-E-and-ℓ-1 (tail es)))))))

;; We can blindly write the final function:

(claim drop-last
       (Π ((E   U  )
           (ℓ-1 Nat))
          ;; The result is the type of a function
          ;; from a vector of at least one element
          ;; to a vector of one fewer elements:
          (→ (Vec E (add1 ℓ-1))
             (Vec E     ℓ-1   ))))

(define drop-last
  (λ (E ℓ-1)
    (ind-Nat ℓ-1
             (mot-drop-last E)
             (base-drop-last E)
             (step-drop-last E))))

;; unit-tests (M-C-x to see results in the REPL):

(drop-last Atom 1 (vec:: 'a (vec:: 'b vecnil)))
(drop-last Atom 0 (vec:: 'b vecnil))


;; Again, due to totality, we can't write or compile
;; an application of drop-last to an empty vector


;; (drop-last Atom 42 vecnil)
;  vecnil requires that the length be zero, not
;   43


;;  ___     _
;; |_ _|_ _| |_ ___ _ _ _ __  ___ _________
;;  | || ' \  _/ -_) '_| '  \/ -_)_ /_ / _ \
;; |___|_||_\__\___|_| |_|_|_\___/__/__\___/


;; Pages 165-168 (fifth printing) are not in any
;; chapter. We know they're not in Chapter 7 because
;; the frame numbers start at 1, and the last frame
;; in Chapter 7 is 73. Plus there is a nice picture
;; on page 164 called "one piece at a time."


;; The frames on these pages are notes on
;; interactive syntax and display format.


;; Because ["the racket REPL is
;; hopeless,"](https://github.com/racket/racket/wiki/The-toplevel-is-hopeless)
;; we can't directly do in Emacs most of the things
;; recommended in the intermezzo. I also verified
;; that they don't work in DrRacket. We can do a
;; little, though, and the results are instructive.


;; I'm commenting them out because the REPL resets
;; the cursor to the output of the TODO lines,
;; forcing me to change buffers and reset the
;; cursor to the end. That's undesirable because
;; I reload this buffer (C-c C-c) frequently.


;; (claim peas-i
;;        (Pi ((n Nat))
;;            (Vec Atom n)))

;; (define peas-i
;;   (λ (n)
;;     (ind-Nat n
;;              (λ (k) (Vec Atom k))       ; motive
;;              vecnil                     ; base
;;              (λ (n-1 ps-1)              ; step
;;                (vec:: TODO TODO)))))


;;   ___ _              _             ___
;;  / __| |_  __ _ _ __| |_ ___ _ _  ( _ )
;; | (__| ' \/ _` | '_ \  _/ -_) '_| / _ \
;;  \___|_||_\__,_| .__/\__\___|_|   \___/
;;                |_|


;; Normal form of (+ 1) -- partial application of +
;; to 1 == (add1 zero). Recall:


;; (define +
;;   (λ (n j) ;; Don't use the name n-1 here.
;;     ;;        target base  step  ; the pattern
;;     ;;       |------|----|-------|
;;     (iter-Nat    n     j   step-+)))


;; (+ 1)
;; (+ (add1 zero))                        destructuring
;; (λ (j)
;;   (iter-Nat (add1 zero) j step-+))     subst. def
;; (λ (j)
;;   (step-+
;;     (iter-Nat   zero                   elimination
;;                 j step-+)))
;; (λ (j)
;;   (add1                                subst. def
;;     (iter-Nat   zero j step-+)))
;; (λ (j) (add1 j))                       subst. def


(claim incr (→ Nat Nat))

(define incr
  (λ (n)
    (iter-Nat n                         ; target
              1                         ; base
              (+ 1))))                  ; step


;; Note that pie doesn't let us write add1 in place
;; of (+ 1), above. Must be that add1 isn't a
;; function?


;; playground.pie> add1
;  ...: add1: expected valid Pie name
;    at: add1
;    in: add1


;; But


;; playground.pie> (+ 1)
;; (the (→ Nat
;;         Nat)
;;      (λ (j)
;;        (add1 j)))


;; The book makes the point that the normal forms
;; of the expressions (+ 1) and incr are not the
;; same. Save some hand calculation by letting
;; the REPL compute the normal forms:


;; playground.pie> (+ 1)
;; (the (→ Nat
;;         Nat)
;;      (λ (j)
;;        (add1 j)))
;;
;; playground.pie> incr
;; (the (→ Nat
;;         Nat)
;;      (λ (n)
;;        (iter-Nat n
;;                  (the Nat 1)
;;                  (λ (j)
;;                    (add1 j)))))


;; "Even though they are not the same, the fact that
;; they always find the same answer can be written
;; as a type.
;;    "Sameness is indeed a judgment. But, with a
;; new type constructor, types can express a new
;; idea called _equality_."


;; -+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f   =
;; -+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 174: "An expression
;;
;;     (= X FROM TO)
;;
;; is a type if X is a type, FROM is an X, and
;; TO is an X."


;; FROM and TO need not be types, but they must be
;; of type X. Therefore, an (= ...) is a dependent
;; type because it depends on things that might not,
;; themselves, be types.


(= Nat (+ 6 7) 13)
; (the U
;      (= Nat 13 13))


;; Frames 8.15-18. There is a lot going on here:
;; Bertrand Russell and lots more.


;; "Types can be read as _statements_."


;; The one above says "6 + 7 equals 13," a
;; statement. "6+7 is the same Nat as 7" is a
;; _judgment_, one of form 2.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   F o u r   F o r m s
;;  o f   J u d g m e n t
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; 1. ____ is a ____.
;;
;; 2. ____ is the same ____ as ____.
;;
;; 3. ____ is a type.
;;
;; 4. ____ and ____ are the same type.


;; Judgments are for humans; statements are for
;; computers; more precisely, for computer
;; theorem-provers or proof assistants.


;; Frame 8.21


;; "'6+7 equals 13' is a type" is a judgment of
;; form 1, a [j1].


;; Π-expressions are statements of universal
;; quantifications, i.e, "for-every," ∀, statements.


;; Frame 8.23


(Π ((n Nat))
   (= Nat (+ 1 n) (add1 n)))
; (the U
;      (Π ((n Nat))
;         (= Nat
;            (add1 n)
;            (add1 n))))


;; I made up the following exercise.


;; Oh, LOOK! The normal forms converged! Is that
;; fact significant? No, because the normal form
;; of (+ 1) is add1. How about this:


(Π ((n Nat))
   (= Nat (+ 1 n) (incr n)))
; (the U
;      (Π ((n Nat))
;         (= Nat
;            (add1 n)
;            (iter-Nat n
;                      (the Nat 1)
;                      (λ (j)
;                        (add1 j))))))


;; ... a much more meaty statement about normal forms!


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f   s a m e
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; My edits after incorporating Frame 8.37, Page 179.


;; The expression (same e3) is an (= X e1 e2) if e1,
;; e2, and e3 are each an X and e1 is the same as
;; e2.


;; Frame 8.37


;; _internalizing_ judgment


(claim twelve
       (= Nat (+ 1 11) (incr 11)))

(define twelve
  (same (incr (incr 10))))  ;; proof of "twelve"


;; Frame 8.38


;; "By combining Π with =, we car write statements
;; that are true for arbitrary Nats, while could
;; only make judgments about particular Nats. Here's
;; an example:"


(claim +1=add1
       (Π ((n Nat))
          (= Nat (+ 1 n) (add1 n))))

(define +1=add1
  (λ (n) (same (add1 n))))


;; ... proves the statement that for every Nat n, (+
;; 1 n) equals (add1 n). Equals, here is the type
;; constructor =.


(claim incr=add1
       (Π ((n Nat))
          (= Nat (incr n) (add1 n))))


;; (define incr=add1
;;   (λ (n)
;;     (same (add1 n))))


;; ... does not work as a proof of the claim because
;; the normal forms of (incr n) and (add1 n) don't
;; match.


;; The normal form of (incr n) is
;;   (iter-Nat n 1 (+ 1 n))
;; (See line 1425).


;; This normal form is neutral, because it's not a
;; value and it cannot (yet) be evaluated because of
;; the variable n.


;; Frame 8.49, Page 182: "... if the target of an
;; eliminator expression is neutral, then the entire
;; expression is neutral."


;; The normal form of (add1 n) is (add1 n)


;; (define incr=add1
;;   (λ (n) (same (iter-Nat n
;;                          1
;;                          (add1 1)))))


;; Frames 8.48-8.49, Page 181: the normal form
;; (iter-Nat n 1 (+ 1)) is neutral because 1. it is
;; not a value (no constructor up top) and 2. it
;; cannot yet be evaluated due to the variable n.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N e u t r a l   E x p r e s s i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 182: "Variables that are not defined are
;; neutral. If the target of an eliminator
;; expression is neutral, then the eliminator
;; expression is neutral. Therefore, values are not
;; neutral."


;; This implication is not obvious to me.
;; https://racket.discourse.group/t/the-little-typer-implicattion-that-values-are-not-neutral/1737


;; ++++++++++++++++++++++++++++++++++++++++++
;; Neutral Expressions are Not Always Normal.
;; ++++++++++++++++++++++++++++++++++++++++++


;; Frames 8.50-8.55:


;; Phaedrus: "Are neutral expressions normal?"


;; Socrates: "Not always. Some types have ways of
;; making neutral expressions into values, and in
;; these cases, the neutral expression is not
;; considered normal because it can be made into a
;; value.


;; Soc: "A neutral expression whose type has Π up
;; top is not normal. This is because a neutral
;; expression f is the same as (λ (x) (f x)), which
;; is a value."


;; Phae: "Why does this mean that f is not normal?
;; If two expressions are the same, then they have
;; identical normal forms."


;; Soc: "By the Final 2nd Cmdmt of λ (p. 140), f is
;; the same as (λ (x) (f x)), but they are not
;; written identically.
;;
;;     "At most one of them can be the normal form.
;; The one wrapped in λ is the normal form. Because
;; expressions with a λ up top are values, they are
;; not neutral. This normal form is not neutral.
;;
;;     "For another example, the only normal forms
;; for pairs have _cons_ up top, so they're not
;; neutral.
;;
;;     "Neutral expressions, like (incr n)'s normal
;; form, (iter-Nat 1 n (+ 1)), occur frequently when
;; =-expressions mention argument names in
;; Π-expressions. That neutral expression is also a
;; normal form."


;; [It could be that the entire point of this
;; digression is simply to clarify that some neutral
;; expressions are not normal and vice versa. We
;; don't have that case here.


;; Phae: "How can we find a definition for incr=add1?
;; `same` doesn't do the job (because the normal forms
;; don't match up) and incr=add1's type has a neutral
;; expression in it?"


(claim base-incr=add1
       (= Nat (incr 0) (add1 zero)))

(define base-incr=add1
  (same (add1 zero)))


(claim mot-incr=add1
       (→ Nat U))

(define mot-incr=add1
  (λ (k)
    (= Nat (incr k) (add1 k))))


;; (claim step-incr=add1
;;        (Π (( n-1 Nat ))
;;           (→ (mot-incr=add1 n-1)
;;              (mot-incr=add1 (add1 n-1)))))

;; (claim step-incr=add1
;;        (Π (( n-1 Nat ))
;;           (→ (= Nat
;;                 (incr n-1)
;;                 (add1 n-1))
;;              (= Nat
;;                 (incr (add1 n-1))
;;                 (add1 (add1 n-1))))))

(claim step-incr=add1
       (Π (( n-1 Nat ))
          (→ (= Nat
                (incr n-1)
                (add1 n-1))
             (= Nat
                (add1 (incr n-1))
                (add1 (add1 n-1))))))


;; cong is an eliminator for =.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f   c o n g
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 190: If f is an (→ X Y)
;; and target is an (= X from to), then
;; then (cong target f) is an (= Y (f from) (f to)).


;; In our example, we must transform
;;    (= Nat
;;       (incr n-1)
;;       (add1 n-1))
;; into
;;    (= Nat
;;       (add1 (incr n-1))
;;       (add1 (add1 n-1))))


(define step-incr=add1
  (λ (n-1)
    (λ (incr=add_n-1)
      (cong incr=add_n-1 (+ 1)))))


(define incr=add1
  (λ (n)
    (ind-Nat n
             mot-incr=add1
             base-incr=add1
             step-incr=add1)))


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   C o m m a n d m e n t   o f   c o n g
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 194: If x is an X and f is an (→ X Y),
;; then (cong (same x) f) is the same
;;   (= Y (f x) (f x))
;; as
;;   (same (f x))


;; Frame 8.89, Page 195


;; Soc: "The interplay between judging sameness and
;; stating equality is at the heart of dependent
;; types. This taste only scratches the surface."


;;   ___ _              _             ___
;;  / __| |_  __ _ _ __| |_ ___ _ _  / _ \
;; | (__| ' \/ _` | '_ \  _/ -_) '_| \_, /
;;  \___|_||_\__,_| .__/\__\___|_|    /_/
;;                |_|





;;   ___ _             _     ___ _            _
;;  / __| |_  ___ __ _| |_  / __| |_  ___ ___| |_
;; | (__| ' \/ -_) _` |  _| \__ \ ' \/ -_) -_)  _|
;;  \___|_||_\___\__,_|\__| |___/_||_\___\___|\__|


;; All page numbers refer to the Fifth Printing.
;; I've gathered together edited transcriptions of
;; the boxed definitions, laws, and commandments
;; according to my own needs. My edits are clearly
;; marked, as are direct quotations from the book.
;; This is a good point to review them all because
;; chapter 8 goes into the weeds with neutral
;; expressions and normal forms.


;; -+-+-+-+-+-+-
;;  V a l u e s
;; -+-+-+-+-+-+-


;; Page 22: "An expression with a constructor [up]
;; top is called a _value_."


;; (add1 0) is a value but (+ 1 0) is not.


;; -+-+-+-+-+-+-+-+-+-+-+-+-
;;  N o r m a l   F o r m s
;; -+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 13: "Given a type, every expression
;; described by that type has a normal form, which
;; the most direct way of writing it. Iff two
;; expressions are the same [according to some
;; type], then they have identical normal forms."


;; This is how Mathematica works: keep rewriting
;; expressions until Mathematica's notion of the
;; normal form is achieved and the expression does
;; not change its syntactical structure by applying
;; any more rules.


;; Frame 1.97, Page 25: "A normal expression has no
;; remaining opportunities for evaluation."


;; I believe this implies that normal forms are
;; unique and that the fact is called The Confluence
;; Theorem.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  V a l u e s   a n d   N o r m a l   F o r m s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 24: "Not every value is a normal form. This
;; is because the arguments [of] a constructor need
;; not be normal. Each expression has only one
;; normal form, but it is sometimes possible to
;; write it as a value[, with a constructor up top,]
;; in more than one way."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N o r m a l   F o r m s   a n d   T y p e s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

;; Frame 1.44, Page 12; also Page 14: "Sameness is
;; always according to a type, so normal forms are
;; also described by a type."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   F i r s t   C o m m a n d m e n t
;;  o f   c o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 15: "Two cons-expressions are the same (Pair
;; A D) if their cars are the same A and their cdrs
;; are the same D. Here, A and D stand for any
;; type[s]."


;; One judges sameness according to a type by
;; writing "two expressions e1 and e2 are the same
;; X," where A is a type. This is a minor variation
;; of a judgment of form 4 (see circa Line 1509).


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N o r m a l   F o r m s   O F   T y p e s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 16: "Every expression that IS a type has a
;; normal form, which is the most direct way of
;; writing that type. Iff two expressions ARE the
;; same type, then they have identical normal
;; forms." (emphasis mine).


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  L a w s   a n d   C o m m a n d m e n t s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page xiii in the Preface: "Laws describe which
;; expressions are meaningful and commandment
;; describe which expressions are the same as others
;; [, with 'same''s having a technical meaning that
;; is spelled out in the Commandments.]"


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  C l a i m s   b e f o r e   D e f i n i t i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  E v a l u a t i o n   &   E x p r e s s i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 25: "In Pie, values are also expressions.
;; Evaluation in Pie finds an expression, not some
;; other kind of thing."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   C o m m a n d m e n t   o f   z e r o
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 26: "zero is the same Nat as zero."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   C o m m a n d m e n t   o f   a d d 1
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 26: "If n is the same Nat as k, then (add1
;; n) is the same Nat as (add1 k)."

;; Frame 100, Page 26: "Two Nat expressions, that
;; are not values, are the same if their values are
;; the same.."


;; This statement implies that evaluation can reduce
;; an expression like (+ 1 0) that is not a value
;; can be reduced to a value like (add1 0).


;; This statement also implies that sameness
;; pertains to expressions, some of which might not
;; be values.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  D e f i n i t i o n s   a r e   F o r e v e r
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Aka, _immutable_.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  C o n s t r u c t o r s   a n d
;;  E l i m i n a t o r s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 33: "Constructors build values [expressions
;; with a constructor up top], and eliminators take
;; apart values built by constructors."


;; I usually pair elimination with a preceding
;; destructuring. See comments near Line 250 in this
;; file.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  E l i m i n a t i n g   F u n c t i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 34: "Applying a function to arguments _is_
;; the eliminator for functions."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   I n i t i a l   L a w
;;  o f   A p p l i c a t i o n
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 38: "If f is an (→ Y X) and arg is a Y, then
;; (f arg) is an X."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   I n t e r m e d i a t e   L a w
;;  o f   A p p l i c a t i o n
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 100: "
;; If f is a
;;   (Π (( Y U ))
;;     X)
;; and Z is a U, then
;;   (f Z)
;; is an X, where every Y has been consistently
;; replaced by Z."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   F i n a l   L a w
;;  o f   A p p l i c a t i o n
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 139: "
;; If f is a
;;   (Π (( y Y ))
;;     X)
;; and Z is a Y, then
;;   (f z)
;; is an X, where every y has been consistently
;; replaced by z."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   F i n a l   L a w   o f   λ
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 139: "
;; If x is an X when y is a Y, then
;;   (λ (y) x)
;; is a
;;   (Π (( y Y ))
;;     X)."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   Final
;;  F i r s t   C o m m a n d m e n t   o f   λ
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 139: "
;; If two λ-expressions can be made the same
;;   (Π (( y Y ))
;;     X)
;; by consistently renaming their variables,
;; then they are the same."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   I n i t i a l
;;  F i r s t   C o m m a n d m e n t   o f   λ
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 38: "Two λ-expressions that expect the same
;; number of arguments are the same if their bodies
;; are the same after consistently renaming their
;; variables."


;; "Consistent renaming" is a lot more subtle than
;; it sounds because preventing collisions of free
;; and bound variable names in deep expressions is
;; error-prone. Errors have occurred in archival
;; papers by great authors. Look up ["de Bruijn
;; Index"](https://en.wikipedia.org/wiki/De_Bruijn_index)
;; for more info.


;; The Little Typer book sweeps the topic of
;; consistent renaming under the rug of "occur" The
;; Initial Second Commandment of λ below and in The
;; Law of Renaming Variables. We don't need to worry
;; about it much, here, but if one is implements Pie
;; or the λ-calculus, one must be wary.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   I n i t i a l
;;  S e c o n d   C o m m a n d m e n t   o f   λ
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 38: "If f is an (→ Y X) then f is the same
;; (→ Y X) as (λ (y) (f y)) [so] long as y does not
;; occur in f [at any level]."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   F i n a l
;;  S e c o n d   C o m m a n d m e n t   o f   λ
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 140: "
;; If f is a
;;   (Π ((y Y))
;;     X)
;; and y does not occur [at any level] in f, then
;; f is the same as
;;   (λ (y)
;;     (f y))."


;; Page 183: "Commandments such as this one are often
;; called η-rules. These normal forms in which all
;; possible η-rules have been applied to make values
;; are called _η-long normal forms.'"


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f
;;  R e n a m i n g   V a r i a b l e s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 39: "Consistently renaming variables can't
;; change the meaning of anything."


;; This law is a requirement, but doesn't give an
;; algorithm, let alone an efficient one, for
;; consistent renaming. The article cited above on
;; de Bruijn Indices introduces some algorithms for
;; consistent renaming.


;;    _  __         __           __
;;   / |/ /__ __ __/ /________ _/ /
;;  /    / -_) // / __/ __/ _ `/ /
;; /_/|_/\__/\_,_/\__/_/  \_,_/_/
;;    ____                           _
;;   / __/_ __ ___  _______ ___ ___ (_)__  ___  ___
;;  / _/ \ \ // _ \/ __/ -_|_-<(_-</ / _ \/ _ \(_-<
;; /___//_\_\/ .__/_/  \__/___/___/_/\___/_//_/___/
;;          /_/


;; This deserves a big heading because it's critical
;; to Chapter 8.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   C o m m a n d m e n t   o f
;;  N e u t r a l   E x p r e s s i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 42: "Neutral expressions ... written
;; identically are the same, _no matter their
;; type_."


;; We must learn about neutral expressions. Rewind
;; to Chapter 2.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N e u t r a l   E x p r e s s i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Frame 2.26, Page 40: "Expressions that are not
;; values and cannot yet be evaluated due to a
;; variable are called _neutral_."


;; This means that (cdr y) is a neutral expression
;; because it is not a value because cdr is not a
;; constructor, but an eliminator. However (λ (y)
;; (cdr y)) is not a neutral expression because it
;; IS a value because λ is a constructor.


;; Frame 2.27, Page 40: "... two occurrences of a
;; variable cannot be replaced by values that are
;; not the same."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   a n d   C o m m a n d m e n t
;;  o f   d e f i n e
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 43: "Following
;;   (claim _name_ X) and (define _name_ _expr_)
;; if
;;   _expr_ is an X                     ; judg. 1
;; then
;;   _name_ is an X                     ; judg. 1
;; and
;;   _name_ is the same X as _expr_     ; judg. 2


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   S e c o n d   C o m m a n d m e n t
;;  o f   c o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 44: "If p is a (Pair A D) [j1] then it is
;; the same (Pair A D) as (cons (car p) (cdr p))
;; [j2]."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  N a m e s   i n   D e f i n i t i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 46: "In Pie, only names that are not already
;; used, whether for constructors, eliminators, or
;; previous definitions, can be used with _claim_ or
;; _define_."


;; -+-+-+-+-+-+-+-+-+-+-+-
;;  T y p e   V a l u e s
;; -+-+-+-+-+-+-+-+-+-+-+-


;; Page 53: "An expression that is described by a
;; type is a value when it has a constructor [up]
;; top. Similarly, an expression that IS a type is a
;; value when it has a type constructor [up] top."


;; Type constructors are things like Nat, Atom, Pair,
;; →, and U.


;; (claim foo54 U)
; cons requires a Pair or Σ type, but was used as a U

(claim foo54 (Pair U U))

(define foo54 (cons Atom Atom))


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  E v e r y   U   i s   a   T y p e
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 55: "Every expression described by U is a
;; type, but not every type is described by U."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   C o m m a n d m e n t   o f   t h e
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 66: "If X is a type and e is an X, then
;;   (the X e)
;; is the same X as e."


;; -+-+-+-+-+-+-+-+-
;;  S a m e n e s s
;; -+-+-+-+-+-+-+-+-


;; Page 70: "If a 'same-as' chart could show that
;; two expressions are the same, then this fact can
;; be used anywhere without further justification.
;; 'Same-As' charts are only to help build
;; understanding."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T o t a l   F u n c t i o n s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 71: "A function that always assigns a value
;; to _every_ possible argument is called a _total
;; function_.


;; Skipping iter-Nat, rec-Nat, which-Nat, rec-List.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f   L i s t
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 110: "If E is a type, then (List E) is a
;; type."


;; Page 120: "All ... entries in a list must have
;; the same type."


;; Skipping Page 131.


;; -+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f   Π
;; -+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 136: "
;; The expression
;;   (Π (( y Y ))
;;     X)
;; is a type when Y is a type, and X is a type if y
;; is a Y."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  U s e   a   M o r e   S p e c i f i c   T y p e
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 137: "Make a function total by using a more
;; specific type to rule out unwanted arguments."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  U s e   i n d - N a t
;;  f o r   D e p e n d e n t   T y p e s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 145: "Use ind-Nat instead of rec-Nat when
;; the [type of the] rec-Nat or ind-Nat expression
;; depends on the target Nat. The [type of the]
;; ind-Nat expression is the motive applied to the
;; target."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  T h e   L a w   o f   i n d - N a t
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; See also "claim iN" around line 948 above.


;; Page 147: "
;; If target is a Nat, mot is an
;;   (→ Nat U)
;; base is a (mot zero) and step is a
;;   (Π ((n-1 Nat))
;;     (→ (mot n-1)
;;     (mot (add1 n-1))))
;; then
;;   (ind-Nat target mot base step)
;; is a
;;   (mot target)."


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  I n d u c t i o n
;;  o n   N a t u r a l   N u m b e r s
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-


;; Page 149: "Building a value for any natural
;; number by giving a value for zero and a way to
;; transform a value for [n-1 into a value for n] is
;; called _induction on natural numbers."
