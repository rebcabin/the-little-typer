#lang pie  ;; Racket support this language as a
           ;; package.


;;   ___ _                _   __       ___
;;  / __| |_  _ __ ___   / | / _|___  |_  )
;; | (__| ' \| '_ (_-<_  | | > _|_ _|  / /
;;  \___|_||_| .__/__(_) |_| \_____|  /___|
;;           |_|


;; In Emacs racket-mode, C-c C-c sends the whole
;; file to the racket interpreter. C-M-x sends the
;; s-exp that surrounds the cursor, just as with
;; CIDER in Clojure-mode.


'spinach

(the (Pair Atom Atom)
  (cons 'spinach 'cauliflower))

(the Atom (the Atom 'pie))


;; -+-+-+-+-+-+-+-+-+-
;;  w h i c h - N a t
;; -+-+-+-+-+-+-+-+-+-


;; which-Nat has type
;; (Π ((E U))
;;   (→ target:N base:E step:(→ N E) E))
;;
;; or, less noisily
;;
;; (Π ((E U))
;;   (→ N E (→ N E) E))


;; The base and the output of step must have the same
;; type (E U). E can be anything -- Atom or Nat, for
;; instance, but it must be the same on both branches
;; of which-Nat.


;; Here is pseudocode for which-Nat:


;; (which-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then which-Nat = (step n-1)


;; A good name for the argument (parameter?) of step
;; is n-1 because step is called with n-1 when
;; target == n == (add1 n-1).


;; A parameter is a name for an argument. What is
;; the name of a parameter (you answer)?


;; SPOILER: Parameters inhabit a space of symbolic
;; calculation inside the compiler or its run-time,
;; representative functions like add1. Names of
;; parameters only appear in the implementations of
;; the compiler or its run-time representative
;; functions, where they may stand for arbitrary
;; parameters. At the user's level. parameters are
;; names for arguments, where they may stand for
;; arbitrary argument values. Recall that values are
;; expressions with constructors up top (in first
;; positions in parenthesized expressions).


(which-Nat zero 'naught (λ (n-1) 'more))
(which-Nat 4    'naught (λ (n-1) 'three))


;; I made up the following to show how rec-Nat can
;; mimic the behavior of which-Nat, i.e., by the
;; step's ignoring both its arguments:


(rec-Nat zero 'rec-naught (λ (n-1 r) 'rec-more))
(rec-Nat 4    'rec-naught (λ (n-1 r) 'rec-three))


;; Notice that rec-Nat "destructures" its argument
;; into (add1 n-1) and then "eliminates" add1 before
;; handing n-1 to the step function, (λ (n-1 r)
;; 'some-atom). We write more about destructuring
;; and elimination below.


;; The book writes _ignored arguments_ in dim font.
;; I think we don't need to bother much about that.
;; But we might sometimes write _ or foo_ with a _
;; suffix for ignored arguments. Lots of programming
;; languages follow that convention, sometimes
;; allowing multiple instances of _ without
;; collision.


;; Later, we'll see that by step's ignoring one of
;; its arguments, namely r, the recursive
;; computation, rec-Nat simulates iter-Nat.


;;   ___ _              _             ____
;;  / __| |_  __ _ _ __| |_ ___ _ _  |__ /
;; | (__| ' \/ _` | '_ \  _/ -_) '_|  |_ \
;;  \___|_||_\__,_| .__/\__\___|_|   |___/
;;                |_|


;; Frame 3.23


;; All these functions follow a pattern, with
;; parameters target, base, and step.


;;        target base      step
;;       |------|----|----------------|
(iter-Nat    5     3  (λ (k) (add1 k)))


;; Discovery about pie (the language of this file).
;; Can't go to point-free form, i.e., cannot use
;; add1 for (λ (k) (add1 k)).
;;
;; (iter-Nat 5 3 add1) ;
;; .../the-little-typer/playground.pie:17:14:
;; add1: expected valid Pie name
;   at: add1
;   in: add1


;; pseudocode for iter-Nat


;; (iter-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then iter-Nat ==
;; (step
;;    (iter-Nat n-1 base step))


;; iter-Nat has type
;;
;; (Π ((E U))
;;   (→ N E (→ N E) E))
;;
;; same as the type of which-Nat. The difference
;; between the two is that iter-Nat calls iter-Nat
;; for the argument of step. User-defined code must
;; not recurse, but this system-defined routine can.


;; (+ 2 3) ;; ; Unknown variable +


(claim step-+
       (→ Nat Nat))

(define step-+
  (λ (n-1) (add1 n-1)))


(claim + (→ Nat Nat Nat))

(define +
  (λ (n j) ;; Don't use the name n-1 here.
    ;;        target base  step  ; the pattern
    ;;       |------|----|-------|
    (iter-Nat    n     j   step-+)))


;; Frame 3.28, sort-of


;; reminder of the pseudocode of which-Nat:


;; (which-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;; then which-Nat = (step n-1)


;; -+-+-+-+-+-+-+-+-+-+-+-
;;  e l i m i n a t i o n
;; -+-+-+-+-+-+-+-+-+-+-+-


;; The process of replacing (add1 n-1) with n-1 is
;; called "elimination" because it strips off --
;; eliminates -- the value constructor add1.
;; Selection (which-Nat), iteration (iter-Nat), and
;; recursion (rec-Nat) occur in a backwards kind of
;; way, by eliminating toward zero. We say
;; "backwards" because your prior experience with
;; recursion and iteration probably has you starting
;; with some big Nat and _subtracting_ 1 from it by
;; an arithmetic process before recursing. Here, in
;; The Little Typer, we instead destructure larger
;; numbers n into smaller ones (add1 n-1) by writing
;; out the _addition_ that "must have taken place."
;; The effect is the same, but preserves type
;; information here. This kind of reckoning is
;; probably best in any implementation of a type
;; system.


;; Sequential deconstruction and elimination *build
;; up* an expression of smaller Nats. The expression
;; that is eventually evaluated to the unique normal
;; form -- the "most direct" form.


;; -+-+-+-+-+-+-+-+-+-+-+-+-+-
;;  d e s t r u c t u r i n g
;; -+-+-+-+-+-+-+-+-+-+-+-+-+-


;; The process of noticing that n == (add1 n-1) is
;; "destructuring," a term not in The Little Typer.
;; I borrowed it from Clojure. It defines the
;; argument n-1 by setting up later elimination of
;; n-1 from (add1 n-1).


;; (iter-Nat target base step) == base if
;; target == 0 else if target == n == (add1 n-1)
;;                               |-------------|
;;                                destructuring
;; then iter-Nat ==        ______/
;;                        /
;;             elimination
;; (step       |---------|
;;    (iter-Nat    n-1    base step))


;; Here is a "same-chart" for "(+ 2 3)." I assume we
;; understand "subst.", i.e., substitution, without
;; further explanation:


(+ 2 3) ; 1. ...                          how? why?
;; 2.     (iter-Nat     2    3 step-+)    subst. def
;; 3.     (iter-Nat (add1 1) 3 step-+)    destructuring
;; 4. (step-+            /                elimination
;;        (iter-Nat     1    3 step-+))
;; 5. (step-+       ____^___
;;        (iter-Nat (add1 0) 3 step-+))   destructuring
;; 6. (step-+            /                elimination
;;      (step-+         |
;;        (iter-Nat     0    3 step-+)))
;;        -------------------v--------
;; 7. (step-+                |            subst. base
;;      (step-+              3))
;; ~~~> 5                                 evaluation


;; Here is something I made up to show that rec-Nat
;; is at least as strong as iter-Nat.


;; (rec-Nat target base step) == base if
;; target == 0 else if target == (add1 n-1)
;; then rec-Nat ==
;; (step n-1                              nota bene
;;    (rec-Nat n-1 base step))            elimination

(claim sr+
       (→ Nat Nat Nat))

(define sr+
  (λ (n-1 r) (add1 n-1))) ;               ignore r


(rec-Nat 2 3 sr+) ; 1. ...
;; 2.     (rec-Nat     2    3 sr+)        subst. def
;;                 ____^___
;; 3.     (rec-Nat (add1 1) 3 sr+)        destructuring
;; 4. (sr+ 1            /                 elimination
;;        (rec-Nat     1    3 sr+))
;; 5. (sr+ 1       ____^___               destructuring
;;        (rec-Nat (add1 0) 3 sr+))
;; 6. (sr+ 0            /                 elimination
;;      (sr+ 0         |
;;        (rec-Nat     0    3 sr+)))
;;        ------------------v-----        subst. base
;; 7. (sr+ 0                |
;;      (sr+ 0              3))
;; ~~~> 5                                 evaluation


;; -+-+-+-+-+-
;;  g a u s s
;; -+-+-+-+-+-


;; Here is an example rec-Nat stepper that uses both
;; arguments that rec-Nat gives it:


(claim step-gauss
       (→ Nat Nat
          Nat))

(define step-gauss
  (λ (n-1 rg)
    (+ (add1 n-1) rg)))


(claim gauss
       (→ Nat Nat))

(define gauss
  (λ (n) ; Don't name this argument n-1
    (rec-Nat n ; "target": if zero, return ...
             0 ; "base": else, if it's (add1 n-1)
             ;; return
             ;; (step-gauss
             ;;   (rec-Nat n-1
             ;;            base
             ;;            step-gauss)
             step-gauss)))


;; Less noisy pseudocode:


;; letting rN == rec-Nat, s == some-stepper, a1 == add1
;; claim s (→ Nat Nat Nat)
;; (rN     0    b s) ~~> b
;; (rN (a1 n-1) b s) ~~> (s n-1 (rN n-1 b s))


(gauss 3) ; 1. ...
;; 2.       (rN    3   0 sg)              subst. def
;;              ___^__
;; 3.       (rN (a1 2) 0 sg)              destructuring
;; 4. (sg 2        /                      elimination
;;          (rN    2   0 sg))
;; 5. (sg 2     ___^__
;;          (rN (a1 1) 0 sg))             destructuring
;; 6. (sg 2        /                      elimination
;;      (sg 1      |
;;          (rN    1   0 sg)))
;; 6. (sg 2        |
;;      (sg 1   ___^__
;;          (rN (a1 0) 0 sg)))            destructuring
;; 7. (sg 2        /                      elimination
;;      (sg 1      |
;;        (sg 0    |
;;          (rN    0   0 sg))))
;; 8. (sg 2 -------v--------
;;      (sg 1      |
;;        (sg 0    0)))                   subst. base
;; 9. (sg 2 (sg 1 (+ (add1 0) 0)))        apply +,
;; A. (sg 2 (sg 1 1))                     including
;; B. (sg 2 (+ (add1 1) 1))               multiple
;; C. (sg 2 3)                            steps not
;; D. (+ (add1 2) 3)                      exploded here
;; E. 6


;;   ___ _              _             _ _
;;  / __| |_  __ _ _ __| |_ ___ _ _  | | |
;; | (__| ' \/ _` | '_ \  _/ -_) '_| |_  _|
;;  \___|_||_\__,_| .__/\__\___|_|     |_|
;;                |_|


;; This chapter is mostly about the miniature
;; calculus on types, a calculus effected by Π. I
;; assume this is easy for you, so I don't talk
;; much, just show some examples. In Emacs, type
;; M-C-x with the cursor in an example to see its
;; value in the pie/racket interpreter.


;; (claim foo (→ A D))
;; page 98:  ~" → is not up to the job "~


;; -+-+-+-+-
;;  f l i p
;; -+-+-+-+-


(claim flip
       (Π ((A U) (D U))
          (→ (Pair A D)
              (Pair D A))))

(define flip
  (λ (A D)
    (λ (p)
      (cons (cdr p) (car p)))))

(flip Nat Nat)

((flip Nat Atom) (cons 17 'apple))

((flip Nat Nat) (cons 2 3))


(claim elim-Pair
       (Π ((A U) (D U) (X U))
          (→ (Pair A D)
              (→ A D X)
              X)))

(define elim-Pair
  (λ (A D X)
    (λ (p f)
      (f (car p) (cdr p)))))

elim-Pair


;; -+-+-+-+-+-+-+-+-
;;  k a r ,   k d r
;; -+-+-+-+-+-+-+-+-


;; These kar and kdr functions are specialized for
;; Nats. kar and kdr are probably lousy names for
;; them, but we'll go with them just to exit the
;; chapter. `elim-pair` is not specialized, so we
;; bracket the function-calls appropriately.


(claim kar
       (→ (Pair Nat Nat) Nat))

(define kar
  (λ (p)
    ((elim-Pair Nat Nat Nat) ; specialized on Nats
               p
               (λ (a d_) a)))) ; ignore argument d

kar

(kar (cons 2 3))


(claim kdr
       (→ (Pair Nat Nat) Nat))

(define kdr
  (λ (pn)
    ((elim-Pair Nat Nat Nat) ; specialized on Nats
               pn
               (λ (a_ d) d)))) ; ignore argument a

(kdr (cons 2 3))


;; Frame 4.50


;; -+-+-+-+-
;;  t w i n
;; -+-+-+-+-


(claim twin
       (Π ((Y U))
          (→ Y (Pair Y Y))))

(define twin
  (λ (Y)
    (λ (x)
      (cons x x))))

((twin Atom) 'pew)


;;   ___ _              _             ___
;;  / __| |_  __ _ _ __| |_ ___ _ _  | __|
;; | (__| ' \/ _` | '_ \  _/ -_) '_| |__ \
;;  \___|_||_\__,_| .__/\__\___|_|   |___/
;;                |_|


;; Frame 5.31


(claim toppings (List Atom))

(define toppings
  (:: 'potato (:: 'butter nil)))

(claim condiments (List Atom))

(define condiments
  (:: 'chives
      (:: 'mayonnaise nil)))


;; -+-+-+-+-+-+-
;;  l e n g t h
;; -+-+-+-+-+-+-


;; reminder of rec-Nat:


;; letting rN == rec-Nat, s == some-stepper, a1 == add1
;; claim s (→ Nat Nat Nat)
;; (rN     0    b s) ~~> b
;; (rN (a1 n-1) b s) ~~> (s n-1 (rN n-1 b s))


;; pseudocode for rec-List:
;; claim s (-> E (List E) X X)            stepper
;; claim b X                              base
;; claim t (List E)                       target


;; letting rL = rec-List, s == some-stepper, :: for
;; destructuring like add1 (the "1" in add1 is
;; analogous to the additional E argument in the
;; stepper, s [Frame 5.27]; the book does not state
;; this, but it's obvious in retrospect!).
;; (rL    nil    b s) ~~> b
;; (rl (:: e es) b s) ~~> (s e es (rL es b s))


(claim step-length
       (Π ((E U))
          (→ E
             (List E)
             Nat
             Nat)))

(define step-length
  (λ (E)
    (λ (e es length-es)
      (add1 length-es))))


(claim length
       (Π ((E U))
          (→ (List E)
              Nat)))

(define length
  (λ (E)
    (λ (es)
      (rec-List es 0 (step-length E)))))


;; Frame 5.42


(claim length-Atom
       (→ (List Atom) Nat))

(define length-Atom
  (length Atom))


;; Frame 5.45


;; -+-+-+-+-+-+-
;;  a p p e n d
;; -+-+-+-+-+-+-


;; step-append is called post-destructuring into
;; (:: e es) and post-elimination of ::, just as with
;; rec-Nat.


(claim step-append
       (Π ((E U))
          (→ E
             (List E)
             (List E)
             (List E))))

(define step-append
  (λ (E)
    (λ (e es append-es)
      (:: e append-es))))


(claim append
       (Π ((E U))
          (→ (List E)
             (List E)
             (List E))))

(define append
  (λ (E)
    (λ (start end)
      (rec-List start end (step-append E)))))


((append Nat) nil nil)
(append Nat nil nil) ; Everything's curried.


(claim append-Nat
       (→ (List Nat)
          (List Nat)
          (List Nat)))

(define append-Nat
  (append Nat))


(append-Nat (:: 1 nil) nil)
(append-Nat nil (:: 2 nil))
(append-Nat (:: 1 nil) (:: 2 nil))


;; -+-+-+-+-+-+-+-
;;  r e v e r s e
;; -+-+-+-+-+-+-+-


(claim snoc
       (Π ((E U))
          (→ (List E) ; start
             E        ; element e
             (List E))))

(define snoc
  (λ (E)
    (λ (start e)
      (append E start (:: e nil)))))


;; The compiler detects, by type analysis, that
;; consing nil onto nil is illegal: it does not
;; produce a List!


;; illegal! compile error! (snoc Nat nil nil)
(snoc Nat nil 1)
(snoc Nat (:: 1 nil) 2)


(claim step-reverse
       (Π ((E U))
          (→ E
             (List E)
             (List E)
             (List E))))

;; step-reverse is called post-destructuring into
;; (:: e es) and post-elimination of ::, just as
;; with rec-Nat. So it gets two arguments, e, es,
;; as well as the recursive "almost," reversed.

(define step-reverse
  (λ (E)
    (λ (e es reversed)
      (snoc E reversed e))))


(claim reverse
       (Π ((E U))
          (→ (List E)
             (List E))))


;; I first wrote the "nil" below without peeking at
;; the answer. But they snuck one in on me, too
;; clever by half! "nil" must be explicitly typed,
;; here.


(define reverse
  (λ (E)
    (λ (es)
      (rec-List es
                (the (List E) nil)
                ;; See sneaky footnote page 125!
                (step-reverse E)))))

(reverse Nat nil)
(reverse Nat (:: 1 nil))
(reverse Nat (:: 2 (:: 1 nil)))


;;   ___ _              _              __
;;  / __| |_  __ _ _ __| |_ ___ _ _   / /
;; | (__| ' \/ _` | '_ \  _/ -_) '_| / _ \
;;  \___|_||_\__,_| .__/\__\___|_|   \___/
;;                |_|


;; two type expressions:


(Vec Atom zero)
(Vec Atom (add1 zero))


;; Vec is like a list that carries its length along
;; with it. A Vec of length 3 is of a different type
;; than a Vec of length 2. We'll have to
;; occasionally pass Nats around to remind certain
;; functions of the Nat part of a Vec type.


;; Here is an instance expression (The Little Typer
;; through chapter 6 does not use the word
;; "instance" in this way, but I use it to mean a
;; value that is not, itself, a type):


(the (Vec Atom zero) vecnil)


;; Frame 6.21


;; head and tail are built-in, but they need
;; type-hints:


(head (the (Vec Atom 1) (vec:: 'a vecnil)))


;; (head (vec:: 'a vecnil))
;; because
; Can't determine a type
;   Source locations:
;   playground.pie:71:6


(tail (the (Vec Atom 1) (vec:: 'a vecnil)))


(claim first-of-one
       (Π ((E U))
          (→ (Vec E 1) E)))

(define first-of-one
  (λ (E)
    (λ (es)
      (head es))))

(first-of-one Atom (vec:: 'shiitake vecnil))


;; Lots of expressions need type hints:


;; See https://stackoverflow.com/questions/75516108/vec-in-the-little-typer/75516109#75516109

(the (Vec Atom 1) (vec:: 'shiitake vecnil))
(the (Vec Atom 1) (vec:: (the Atom 'shiitake) vecnil))
(the (Vec Atom 1) (vec:: (the Atom 'shiitake)
                         (the (Vec Atom zero) vecnil)))
(the (Vec Atom 1) (vec:: 'shiitake
                         (the (Vec Atom zero) vecnil)))


;; -+-+-+-+-+-
;;  f i r s t
;; -+-+-+-+-+-


;; Frames 6.34 through 6.37


;;   __       __       ___ __
;;  / /____  / /____ _/ (_) /___ __
;; / __/ _ \/ __/ _ `/ / / __/ // /
;; \__/\___/\__/\_,_/_/_/\__/\_, /
;;                          /___/


;; This version of `first` requires a Nat argument,
;; ℓ-1, that is one fewer than the length of the
;; Vec. The argument must be one fewer than the
;; length so that `first` be a total function; so
;; that neither its input nor its output may ever be
;; vecnil, that is, the sole (Vec E 0). `First`
;; guarantees totality by destructuring ℓ-1 into
;; (add1 ℓ-1), which may never be zero, then
;; eliminating add1 to yield ℓ-1, which can be zero.


;; The requirement that all functions be total gives
;; the type system great power to reject values that
;; might diverge, i.e., be non-terminating or empty.


;; First must be total, so its base type must be
;; some Vec with at least one element. The _type_
;; (Vec E (add1 ℓ-1)) tells the whole story!


(claim first
       (Π ((E U)
           (ℓ-1 Nat))
          (→ (Vec E (add1 ℓ-1))
             E)))

(define first
  (λ (E ℓ-1)
    (λ (es)
      (head es))))

(first Atom 2 (vec:: 'a (vec:: 'b (vec:: 'c vecnil))))
(first Atom 0 (vec:: 'a vecnil))


;; The book captures the lesson about totality in
;; the slogan "Use a More Specific Type ... to weed
;; out unwanted arguments" on page 137.


;; The rest of Chapter 6 seems to me just to
;; enshrine standard facts about the form of lambda
;; calculus at the type level, the form that uses
;; GREEK CAPITAL LETTER PI, Π.


;;   ___ _              _             ____
;;  / __| |_  __ _ _ __| |_ ___ _ _  |__  |
;; | (__| ' \/ _` | '_ \  _/ -_) '_|   / /
;;  \___|_||_\__,_| .__/\__\___|_|    /_/
;;                |_|


;; (define peas
;;   (λ (how-many-peas)
;;     (rec-Nat how-many-peas ; target
;;              vecnil        ; base: type?
;;              (λ (ℓ-1_ peas_ℓ-1) ; uh-oh
;;                (vec:: 'pea peas_ℓ-1)))))  ; type?


;; -peas- does not have a consistent type. rec-Nat
;; requires the type of `base` to be the


;; Frame 7.28


(claim base-last
       (Π ((E U))
          (→ (Vec E (add1 zero)) E)))

(define base-last
  (λ (E)
    (λ (es)
      (head es))))


(claim mot-last
       (→ U Nat U))

(define mot-last
  (λ (E k)
    (→ (Vec E (add1 k)) E)))


(mot-last Atom zero)


(Vec U zero)
(the (Vec U zero) vecnil)


(claim step-last
       (Π ((E U)
           (ℓ-1 Nat))
          (→ (mot-last E ℓ-1)
             (mot-last E (add1 ℓ-1)))))

(define step-last
  (λ (E ℓ-1)
    (λ (last-ℓ-1)
      (λ (es)
        (last-ℓ-1 (tail es))))))


(claim last
       (Π ((E U)
           (ℓ-1 Nat))
          (→ (Vec E (add1 ℓ-1)) E)))

(define last
  (λ (E ℓ-1)
    (ind-Nat ℓ-1
             (mot-last E)
             (base-last E)
             (step-last E))))

(last Atom 1 (vec:: 'a (vec:: 'b vecnil)))
